{"posts":[{"title":"二分查找算法","text":"🚀 问题描述给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标 123456789101112131415array = [1,2,3,4,5]left=0right=len(array)-1#这是目标数target = 4while left&lt;=right: mid = (left+right)//2 if target &lt; array[mid]: right = mid-1 elif target &gt; array[mid]: left = left+1 else: print(f'这个目标数的下标是⭐{mid}⭐') break 解析属于暴力解法，从第一个元素依次试出 在while循环里，首先找到中间值【//】是返回一个不大于原数（原数不巧很有可能是小数）的一个整数 第一个if，如果这个目标数小于中间值，那么说明右边界需要缩短范围，由于不包含它，所以需要减一 在第二个if中，如果目标值大于中间值，那么说明目标值在中间值的右侧，左边界需要缩短范围，由于不包含原本的界限，所以需要加一 如果都相等了，那么就会走else路线并将最终的mid输出 我个人的理解：这样记“是闭就沾一”，我的意思是 左闭 left = middle+1, 右闭 right = middle-1 。“两闭加等于” 如果是两个闭区间 while(left &lt;= right)","link":"/2022/12/15/BinarySearch/"},{"title":"CSS 朝花夕拾","text":"🥝 四个定位 absolute 元素会脱离文档流，如果设置偏移量，会影响其他元素的位置定位 relative 相对于原来位置移动，元素设置此属性之后仍然处在文档流中，不影响其他元素的布局 static 是默认的 fixed 以body为参照物 123overflow : hidden /*溢出隐藏给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。*/","link":"/2022/09/12/CSS%20%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"},{"title":"Echarts 探索","text":"🥝 引入后，将图表setOption()到容器中在这个饼状图demo中 title标题 text 主标题 subtext 副标题 left 标题的位置 legend项目 orient 水平呈现方式（决定是横着显示还是竖着显示） left 决定位置 series参数 name 起个名字 type 图表类型 radius 数值越大，半径越大 data 数据 value 占比重 name 名字 tooltip emphasis忘了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.3.3/echarts.common.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;style&gt; body { display: flex; justify-content: center; align-items: center; }&lt;/style&gt;&lt;body&gt; &lt;!-- 为 ECharts 准备一个定义了宽高的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = { title: { text: 'Referer of a Website', subtext: 'Fake Data', left: 'center' }, tooltip: { trigger: 'item' }, legend: { orient: 'vertical', left: 'left' }, series: [{ name: 'Access From', type: 'pie', radius: '60%', data: [{ value: 1048, name: '搜索引擎' }, { value: 735, name: 'Direct' }, { value: 580, name: 'Email' }, { value: 484, name: 'Union Ads' }, { value: 300, name: 'Video Ads' } ], emphasis: { itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' } } }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/07/27/Echarts%20%E6%8E%A2%E7%B4%A2/"},{"title":"Flex布局","text":"🌰 总结用于父元素的属性 display:flex; flex-direction 修改主轴的方向（本来横着的，加了flex-direction:column 就变竖着的了） flex-warp 让我们的元素到底换不换行 justify-content Y轴上的分布方式 align-items X轴上的分布方式 用于子元素的属性 flex-grow(flex) 占据网页剩余的部分所有的空间 就像这样👇 -|—–|- （所有都加1会均等的分割，自适应） flex-shrink 如果父元素一直缩小 会被挤压 可以被压缩的 如果设置为0 是不可被压缩flex-basis 其实就是初始大小align-self 会使得父元素赋予它的属性失效，同时它可以有自己的想法order 更改排序前后顺序权重 align-items和justify-content都是用来决定弹性容器内项目的位置align-items是对项目在容器竖向进行操作的justify-content是对项目在容器横向进行操作letter-spacing 字间距","link":"/2022/07/26/Flex%E5%B8%83%E5%B1%80/"},{"title":"关于promise、async await的理解","text":"🏹 Promise用来优化回调地狱问题 使代码可读性更高Promise方法会有两个参数，条件为真，会执行参数一，否则会执行参数二，执行参数一之后.then 否则catch数据的传递是直接用参数，并且在每个回调函数里面不能马上处理数据，需要下一个.then 或者 catch来打印。 async await async ：是用来定义此函数是一个异步函数，也只有在异步函数里才能使用await关键字 123456async function name(params) { //这是一个异步函数 let resultA = await requestResultA() let resultB = await requestResultB(resultA) console.log(resultB); } resultA返回的是一个promiseawait字面意思是等待 当程序执行到第一个await ，计算机需要完全将 requestResultA() 执行完才会 执行下面的代码。假如不这样，代码会一股脑的运行到低，其中的数据压根来不及处理 1234//回忆一下async function XX(){ { data : ref } = await 一个Promise返回对象} 使用 try catch语句捕捉async catch出现的错误，但try里的代码还是会正常执行 Promise 是一个异步操作，当它忙于工作时，主程序可以继续，不会阻碍进步","link":"/2022/07/29/JS%E5%BC%82%E6%AD%A5/"},{"title":"JavaScript 朝花夕拾","text":"🗡 pop() 默认移除列表中的最后一个元素，并且返回该元素之值 1234const month = new Date().getMonth();//结果为当前月份-1，是因为他是从0记起，通常是为了配合数组const day = new Date().getDay();//结果为当前是几号，很正常 while 当循环 123while(条件为真){ //code} do while 尝试 1234do{ //code} while (条件为真); 12345678const npc= npcs[0]console.log('npcs[0] has the following properties ...');//其中 prop是新的变量 它相当于键for(let prop in npc){ console.log(prop +':' +npc[prop]);} 最后一个循环列表.forEach() 12345678910let arr = [1,2,3]let i = 0arr.forEach(npc =&gt; { console.log(`no.${i}个数字是${npc}`) i+=1})//其实也是抽离列表里每个元素//是变量 跟一个箭头 和大括号 类 1234567891011121314151617181920212223242526class Game{ constructor(name,lives){ this.name = name this.lives =lives } get fName1(){ //code console.log(1); } get fName2(){ //code console.log(2); } fName3(){ console.log(3); }}const game = new Game(&quot;KaiKai&quot;,3)//其中constructor，是关键字 绝不能省、是本类的主心骨//get 是为其添加属性，使用时只需要像那样调取成员变量即可//如果是想调用一个方法像这样👉game.fName3(//这是参数)就不需要加参数，但如果你硬打印的话只会打印出来你这个函数的文本 留意在导入时 一定要在src标签上 添加type=’module’导入👇加{A}代表只导入源js文件中一定含有export const A = 42 不加的话就是 export default 42 Math 1a.distanceTo(c).toFixed(2) 从a到c的距离，以小数点后两位四舍五入 call apple bind的区别共同点：都可以改变函数体里的this指向 函数.call() 函数.apply() 函数.bind()区别 call apply 可以立即执行 ，但bind不会立即执行，他返回的是一个函数，需要加括号才能执行 apply第二个参数是数组，call和bind是罗列关系 添加事件 1window.addEventListener(&quot;一个事件&quot;，触发的一个函数,是否捕获) 事件列表👇 鼠标事件 click 当用户点击某个对象时调用的事件句柄。 contextmenu 在用户点击鼠标右键打开上下文菜单时触发 dblclick 当用户双击某个对象时调用的事件句柄。 mousedown 鼠标按钮被按下。 mouseenter 当鼠标指针移动到元素上时触发。 mouseleave 当鼠标指针移出元素时触发 mousemove 鼠标被移动。 mouseover 鼠标移到某元素之上。 mouseout 鼠标从某元素移开。 mouseup 鼠标按键被松开。 键盘事件 属性 描述 DOM keydown 某个键盘按键被按下。 keypress 某个键盘按键被按下并松开。 keyup 某个键盘按键被松开。 框架/对象（Frame/Object）事件 abort 图像的加载被中断。 ( ) beforeunload 该事件在即将离开页面（刷新或关闭）时触发 error 在加载文档或图像时发生错误。 ( , 和 ) hashchange 该事件在当前 URL 的锚部分发生修改时触发。 load 一张页面或一幅图像完成加载。 pageshow 该事件在用户访问页面时触发 pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 resize 窗口或框架被重新调整大小。 scroll 当文档被滚动时发生的事件。 unload 用户退出页面。 ( 和 ) 表单事件blur 元素失去焦点时触发 change 该事件在表单元素的内容改变时触发( , , , 和 ) focus 元素获取焦点时触发 focusin 元素即将获取焦点是触发 focusout 元素即将失去焦点是触发 input 元素获取用户输入是触发 reset 表单重置时触发 search 用户向搜索域输入文本时触发 剪贴板事件 copy 该事件在用户拷贝元素内容时触发 cut 该事件在用户剪切元素内容时触发 paste 该事件在用户粘贴元素内容时触发 打印事件 afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 beforeprint 该事件在页面即将开始打印时触发 拖动事件 drag 该事件在元素正在拖动时触发 dragend 该事件在用户完成元素的拖动时触发 dragenter 该事件在拖动的元素进入放置目标时触发 dragleave 该事件在拖动元素离开放置目标时触发 dragover 该事件在拖动元素在放置目标上时触发 dragstart 该事件在用户开始拖动元素时触发 drop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 abort 事件在视频/音频（audio/video）终止加载时触发。 canplay 事件在用户可以开始播放视频/音频（audio/video）时触发。 canplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。 durationchange 事件在视频/音频（audio/video）的时长发生变化时触发。 emptied The event occurs when the current playlist is empty ended 事件在视频/音频（audio/video）播放结束时触发。 error 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 loadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。 loadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。 loadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。 pause 事件在视频/音频（audio/video）暂停时触发。 play 事件在视频/音频（audio/video）开始播放时触发。 playing 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。 progress 事件在浏览器下载指定的视频/音频（audio/video）时触发。 ratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。 seeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。 seeking 事件在用户开始重新定位视频/音频（audio/video）时触发。 stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 suspend 事件在浏览器读取媒体数据中止时触发。 timeupdate 事件在当前的播放位置发送改变时触发。 volumechange 事件在音量发生改变时触发。 waiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件 animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 transitionend 该事件在 CSS 完成过渡后触发。 其他事件 message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 online 该事件在浏览器开始在线工作时触发。 offline 该事件在浏览器开始离线工作时触发。 popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 待补充","link":"/2022/08/03/JavaScript%20%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"},{"title":"JS闭包","text":"🔥 有函数嵌套 引用局部变量 返回函数 创建一个对象变量 其实就是一种开发习惯规范","link":"/2022/08/01/JS%E9%97%AD%E5%8C%85/"},{"title":"Lua Record 1","text":"👾 元表 Metatable是普通表基础之上扩展的，有很多元方法，为表添加操作符 打印 a 只会输出 类型和地址 两个重要的函数请留意： Lua数组中，下标是从[1]开始 setmetatable(table,metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败 __metatable👇 一个Meta表只能作为一个普通表的Meta表 getmetatable(table): 返回对象的元表(metatable) __index 元方法","link":"/2023/01/10/Lua%20Record%201/"},{"title":"Lua 编程和游戏开发","text":"👾 需要用到 LOVE 这个软件，它类似于游戏引擎、语言解释器 而且不用安装 Lua (读作/ 撸啊 /) 环境了 🚪官网👉https://www.love2d.org/ 绘制内容应该放置于 一个叫做 love.draw() 的函数内 才会执行 加载资源应该放置于 一个叫做 love.load() 的函数内才会执行 打印字体 ＆ 设置字体 分支123456789101112message = 0function love.draw() ------------------------ if message &gt; 10 then message = 1 elseif message &lt; 10 then message = -1 end ------------------------- love.graphics.print(message)end 循环 while ＆ for12345678910message = 0function love.draw() love.graphics.setFont(love.graphics.newFont(50)) while message &lt; 10 do message = message + 1 -- 不支持 += end love.graphics.print(message)end 12345678910message = 0for i = 1, 7, 2 do message = message + 1 function love.draw() love.graphics.print(message) love.graphics.setFont(love.graphics.setNewFont(50)) endend --i👉 1，3，5，7 循环了四次 那三个参数的意思是初始值，终点值，每次增加的值 自定义函数它运行的顺序 不如c#人性化 1234567891011function run(i) message = iend--message = 0--run(99)function love.draw() love.graphics.print(message)end 遍历表 其中 i 为键，s 为值，ipairs() 去遍历某个表 绘制、鼠标事件123456789101112131415161718192021222324252627282930313233343536function love.load() target ={} target.x = 300 target.y = 300 target.radius = 50 score = 0 timer = 0 gameFont = love.graphics.newFont(40)endfunction love.update(dt)endfunction love.draw() love.graphics.setColor(1,0,0) love.graphics.circle(&quot;fill&quot;,target.x,target.y,target.radius) love.graphics.setColor(1,1,1) love.graphics.setFont(gameFont) love.graphics.print(score,0,0) --fill 矩形 --line 边框 --从0，0 到 200，100end--1左键、2右键、3滑轮function love.mousepressed(x, y , button, isTouch) if button == 1 then score = score + 1 endend 判断是否在圆内用二维的距离公式 123function distanceBetween(x1, y1, x2, y2) return math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2)end 修复 数字闪动 bug 有点内存溢出的感觉，一般都是拆成两个部分 载入图片 ＆ 显示到窗口 ＆ 图片追随鼠标1sprites.crosshairs =love.graphics.newImage(&quot;/Assets/crosshairs.png&quot;) 12--其中love.mouse是获取鼠标的一些属性love.graphics.draw(sprites.crosshairs,love.mouse.getX(),love.mouse.getY()) 请留意：图层顺应取决于生成顺序","link":"/2022/12/06/Lua%20%E7%BC%96%E7%A8%8B%E5%92%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"title":"Markdown 标注快捷键","text":"🖊 编辑器 插件 快捷键： ctrl + i 👉 斜体 ctrl + b 👉 加粗","link":"/2022/09/12/Markdown%20%E6%A0%87%E6%B3%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"MongoDB Record 1","text":"🥭 官网社区版下载地址：https://www.mongodb.com/try/download/community下载zip绿色版，需要配置环境变量将解压目录下的bin添加入Path检测安装是否成功 ：cmd👉 mongod -version出现版本号即可","link":"/2022/07/27/MongoDB%20Record%201/"},{"title":"Node 探索","text":"🥑 NodeJS完全兼容es6语法 模板字符串在字符串中插入 变量or表达式 触发标记：this is string ${变量or表达式}好处是不用拼接，显得利索 readFileSync()读取文件参数一：path参数二：字体编码 writeFileSync()写入文件参数一：path 留意，要指定名字和文件格式参数二：内容是所谓的同步方式 当有多用户时，会阻塞，只有采用异步（Python也是单线程）","link":"/2022/07/28/Node%20%E6%8E%A2%E7%B4%A2/"},{"title":"PICO API","text":"🔫 获取设备的按键 12345678// 左手控制器Vector2 resultLeft;leftController.inputDevice.TryGetFeatureValue(CommonUsages.⭐primary2DAxis⭐,out resultLeft);// 右手控制器Vector2 resultRight;leftController.inputDevice.TryGetFeatureValue(CommonUsages.⭐primary2DAxis⭐,out resultRight); 来自Unity官方API手册 原版CommonUsages class in UnityEngine.XR/Implemented in:UnityEngine.XRModuleLeave feedbackDescriptionDefines static variables that are used to retrieve input features from XR.InputDevice.TryGetFeatureValue. Use these static variables to retrieve common feature values by usage for an XR.InputDevice. Static Properties batteryLevel Value representing the current battery life of this device.centerEyeAcceleration The acceleration of the center eye on this device.centerEyeAngularAcceleration The angular acceleration of the center eye on this device, formatted as euler angles.centerEyeAngularVelocity The angular velocity of the center eye on this device, formatted as euler angles.centerEyePosition The position of the center eye on this device.centerEyeRotation The rotation of the center eye on this device.centerEyeVelocity The velocity of the center eye on this device.colorCameraAcceleration The acceleration of the color camera on this device.colorCameraAngularAcceleration The angular acceleration of the color camera on this device, formatted as euler angles.colorCameraAngularVelocity The angular velocity of the color camera on this device, formatted as euler angles.colorCameraPosition The position of the color camera on this device.colorCameraRotation The rotation of the color camera on this device.colorCameraVelocity The velocity of the color camera on this device.deviceAcceleration The acceleration of the device.deviceAngularAcceleration The angular acceleration of this device, formatted as euler angles.deviceAngularVelocity The angular velocity of this device, formatted as euler angles.devicePosition The position of the device.deviceRotation The rotation of this device.deviceVelocity The velocity of the device.eyesData An Eyes struct containing eye tracking data collected from the device.grip Represents the users grip on the controller.gripButton A binary measure of whether the device is being gripped.handData Value representing the hand data for this device.isTracked Informs to the developer whether the device is currently being tracked.leftEyeAcceleration The acceleration of the left eye on this device.leftEyeAngularAcceleration The angular acceleration of the left eye on this device, formatted as euler angles.leftEyeAngularVelocity The angular velocity of the left eye on this device, formatted as euler angles.leftEyePosition The position of the left eye on this device.leftEyeRotation The rotation of the left eye on this device.leftEyeVelocity The velocity of the left eye on this device.menuButton Represents a menu button, used to pause, go back, or otherwise exit gameplay.primary2DAxis The primary touchpad or joystick on a device.primary2DAxisClick Represents the primary 2D axis being clicked or otherwise depressed.primary2DAxisTouch Represents the primary 2D axis being touched.primaryButton The primary face button being pressed on a device, or sole button if only one is available.primaryTouch The primary face button being touched on a device.rightEyeAcceleration The acceleration of the right eye on this device.rightEyeAngularAcceleration The angular acceleration of the right eye on this device, formatted as euler angles.rightEyeAngularVelocity The angular velocity of the right eye on this device, formatted as euler angles.rightEyePosition The position of the right eye on this device.rightEyeRotation The rotation of the right eye on this device.rightEyeVelocity The velocity of the right eye on this device.secondary2DAxis A secondary touchpad or joystick on a device.secondary2DAxisClick Represents the secondary 2D axis being clicked or otherwise depressed.secondary2DAxisTouch Represents the secondary 2D axis being touched.secondaryButton The secondary face button being pressed on a device.secondaryTouch The secondary face button being touched on a device.trackingState Represents the values being tracked for this device.trigger A trigger-like control, pressed with the index finger.triggerButton A binary measure of whether the index finger is activating the trigger.userPresence Use this property to test whether the user is currently wearing and/or interacting with the XR device. The exact behavior of this property varies with each type of device: some devices have a sensor specifically to detect user proximity, however you can reasonably infer that a user is present with the device when the property is UserPresenceState.Present. 机翻版常用 类在统一引擎.XR/实施地点：统一引擎留下反馈描述定义用于从 XR 检索输入要素的静态变量。InputDevice.TryGetFeatureValue. 使用这些静态变量按 XR 的用法检索公共特征值。输入设备。 静态属性电池级别 表示此设备当前电池寿命的值。中心眼加速 此设备上中心眼的加速度。中心眼角加速 此设备上中心眼的角加速度，格式为欧拉角。中心眼角速度 此设备上中心眼的角速度，格式为欧拉角。中心眼位置 中心眼图在此设备上的位置。中心眼旋转 此设备上中心眼的旋转。中心眼速 此设备上中心眼的速度。彩色相机加速 此设备上彩色相机的加速。颜色相机角度加速 此设备上彩色相机的角加速度，格式为欧拉角。颜色相机角度垂直度 此设备上彩色相机的角速度，格式为欧拉角。颜色相机位置 彩色相机在此设备上的位置。颜色相机旋转 此设备上彩色相机的旋转。颜色相机速度 此设备上彩色相机的速度。设备加速 设备的加速度。设备角度加速 此设备的角加速度，格式为欧拉角。设备角度垂直度 此设备的角速度，格式为欧拉角。设备位置 设备的位置。设备旋转 此设备的旋转。设备高速度 设备的速度。眼睛数据 包含从设备收集的眼动追踪数据的眼睛结构。握 表示控制器上的用户控制滑块。握把按钮 设备是否被抓握的二进制度量。手数据 表示此设备的手部数据的值。已跟踪 通知开发人员当前是否正在跟踪设备。左眼加速 此设备上左眼的加速度。左眼角加速 此设备上左眼的角加速度，格式为欧拉角。左眼角速度 此设备上左眼的角速度，格式为欧拉角。左眼位置 左眼在此设备上的位置。左眼旋转 此设备上左眼的旋转。左眼速 此设备上左眼的速度。菜单按钮 表示菜单按钮，用于暂停、返回或以其他方式退出游戏玩法。主轴2 设备上的主触摸板或操纵杆。primary2D轴单击 代表正在单击或以其他方式按下的主 2D 轴。Primary2D轴触摸 表示正在触摸的主 2D 轴。主按钮 在设备上按下的主面部按钮，或唯一按钮（如果只有一个可用）。主要触摸 设备上正在触摸的主要人脸按钮。右眼加速 此设备上右眼的加速度。右眼角加速 此设备上右眼的角加速度，格式为欧拉角。右眼角速度 此设备上右眼的角速度，格式为欧拉角。右眼位置 右眼在此设备上的位置。右眼旋转 此设备上右眼的旋转。右眼速度 此设备上右眼的速度。辅助2D轴 设备上的辅助触摸板或操纵杆。辅助2D轴点击 代表正在单击或以其他方式按下的辅助 2D 轴。次要2D轴触摸 表示正在触摸的辅助 2D 轴。次级按钮 在设备上按下辅助人脸按钮。次要触摸 设备上正在触摸的辅助人脸按钮。跟踪状态 表示正在为此设备跟踪的值。触发 扳机状控件，用食指按下。触发按钮 食指是否激活触发器的二进制度量。用户存在 使用此属性可以测试用户当前是否正在佩戴和/或与 XR 设备交互。此属性的确切行为因每种类型的设备而异：某些设备具有专门用于检测用户邻近性的传感器，但是当属性为 UserPresenceState.Present 时，您可以合理地推断出用户与设备在一起。 请留意有些按钮可以根据力度控制","link":"/2022/09/13/PICO%20API/"},{"title":"Pico常用事件","text":"🎮 用手柄来操作左右扭头请留意：创建的XR Origin（头显）是基于设备（device-based）给头显添加一个turn provider组件把locomotion system拖拽到snap turn p…的system属性里 然后下面的controllers属性是来决定哪只手柄来控制左右扭头 ⭐需要按➕号⭐ 【头显的基本设置，也就是说要完成这些操作，才可以实现扭头】 PicoNeo3射线の回调函数//给被交互的东西添加simple组件//常用的就四个，悬停进入、悬停退出、选择进入、选择退出 123456789101112131415161718using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.XR.Interaction.Toolkit;public class ShowPanel : MonoBehaviour{ public GameObject canvas; public void HoverEntered(HoverEnterEventArgs inter) { this.gameObject.SetActive(true); } public void HoverExited(HoverExitEventArgs inter) { this.gameObject.SetActive(false); }} 注意：写完还需要注册一下才会生效","link":"/2022/09/25/PicoVR%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6/"},{"title":"PicoVR游戏开发 1","text":"🔫 环境 Unity版本：越新越好，最好2021+JDK、Android SDK、Android NDK以上这些直接在hub内安装，假如一个一个安装会令人去世 JDK8从360软件宝库下载的，第一个就是Android SDK需要下载安卓死丢丢~NDK是从Android Studio下载的一个压缩包Gradle 这个依赖包也是他们官网下载的 我选择的版本是6.9.1 -all.zip版本 1.官网下载PICO SDK👉https://developer-global.pico-interactive.com/sdk?deviceId=1&amp;platformId=1&amp;itemId=12 2.解压这个zip3.新建一个Unity项目，并且换成安卓平台，导入解压好的SDK 请留意是from disk那个选中所在目录的package.json即可导入 随后可能需要设置，什么什么版权等等 忽略即可4.启用PICO SDK👉edit -&gt; project settings -&gt; XR Plugin-in Management勾选Pico XR 项目就可以在PicoXR上适配。5.设置Minimum API Level点击菜单栏 edit -&gt; project settings -&gt; player -&gt; others Settings -&gt; identification 将Minimum API Level设置为Android 8.0 设置这个是因为Pico SDK内置的aar依赖组件，最低支持的Android版本为Android 8.0，而Pico Neo 3本身其实是一个Android 10的ROM 编写Hello World并运行在Pico上1.在Unity工程，Hierarchy下右击SampleScene场景，先创建一个Room-Scale XR Rig对象👇所有的东东3.运行项目 将你的Pico Neo3用USB数据线连接你的电脑，并且开启Neo3的开发者模式。（不知道怎么开启开发者模式的，请看这里：https://sdk.picovr.com/docs/FAQ/chapter_one.html） 点击菜单栏 file -&gt; build settings，打开Build Settings弹窗 先在Platform里选择Android，再点击右下角Switch Platform，这样就将目标平台切换到了Android","link":"/2022/09/12/PicoVR%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%201/"},{"title":"PicoVR游戏开发 3","text":"🎮 注意Canvas是从XR分类下创建的👉同时会创建一个事件系统 使得UI和画布更清晰更改canvas👉canvas scaler的Dynamic pixel per unit 和 reference pixels per unity 前者是作用于文字，后者作用于精灵，前者越大越清晰，后者越小越清晰精灵就是图片啊 等等 UI调用方法挂载一个cs脚本、选中ui的button的onclick 为它触发脚本内的一个方法 滑杆UIUI👉Slider 点击事件 触发事件是需要把组件放到 被交互的物体上，假如我想坐在椅子上，我应该给椅子添加此组件grab是添加一个抓取效果，但有时我们只是想触发一些自己的事件，这个时候就需要simple组件，它只是简单的做回调 simple支持的动作 更换材料 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.XR.Interaction.Toolkit;public class SimpleInteractorController : MonoBehaviour{ public GameObject ball; public Material blue, yellow, grey; public void onSelected(XRBaseInteractor interactor) { } public void onDeSelected(XRBaseInteractor interactor) { } public void onHoverEnter(XRBaseInteractor interactor) { ball.GetComponent&lt;MeshRenderer&gt;().material = blue; } public void onHoverExit(XRBaseInteractor interactor) { } public void onActivated(XRBaseInteractor interactor) { } public void onDeActivated(XRBaseInteractor interactor) { }}//其实很好理解，获取一个物体的组件の网格渲染器の材料 ，并将它设置为blue 按键pico手柄 左键是X Y 右手是A B但实际体现在代码里 其实是 主键和副🗡","link":"/2022/09/12/PicoVR%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%203/"},{"title":"PicoVR游戏开发 4","text":"🎮 解决穿模遗留的坑即便非VR游戏也是一样的办法 就是去修改相机的近视点 👇 表示不在这个射程范围的东西都看不见修改近视点 请留意：近视点 🐟 远视点 的范围越大 显卡的渲染压力随之上升 先做出来，然后慢慢做效果，打磨移除🎮射线效果握住光剑底部首先给 🎮与光🗡模型的中间添加一个 空物体，作为光🗡的父组件这样就变相的改变了光🗡的握把位置","link":"/2022/09/12/PicoVR%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%204/"},{"title":"Python批量修改文件名中的特定字符","text":"🐖 起因 由于👴下载的教程视频中的字幕命名不当，导致PotPlayer播放器无法识别对应字幕文件，因此便用Python批量删除字幕的文件名中的特定字符与视频名字匹配 123456789101112131415161718192021import osimport operatorlsAll = os.listdir(&quot;./&quot;)for k, v in enumerate(lsAll): if(os.path.isdir(v) == True ): path = os.getcwd()+'/'+v+'/' os.chdir(path) strlsAll = os.listdir(&quot;./&quot;) #🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝这个for循环用来给每个子文件夹重命名 for v in strlsAll: if (operator.contains(v,'.srt')): FileName, fileType = os.path.splitext(v) print(FileName) os.rename(v,FileName[:-3]+fileType) os.chdir('../') 我来解释一下，首先列出本文件夹中所有文件夹，程序进入第一个文件夹为符合后缀的文件命名，命名完成，程序返回上一级目录，再为第二个文件夹中的文件命名，依此类推","link":"/2022/08/06/Python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%AD%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6/"},{"title":"Pico设备VR游戏开发 2","text":"🔫 今天学了两种移动方式一个是侧边按键移动、一个是固定锚点移动我个人评价是这种交互模式挺古老的，就好像早先的伪3D 用手柄来操作转向的细节在XR Rig上添加一个Snap turn Provider，并将locomotion system 拖进 Snap turn Provider的system 那个框框里，随后在controller里决定使用哪个摇杆控制扭头 给球添加一个抓手组件👉 grab 一个直接可以和手交互的控制器组件👉 directpicoSDK提供了 左右手的模型 铰链组件👉 joint给父组件 添加嗷~作用 是整个物体绕着某个三维点旋转，一般需要限制来模拟真实世界的物理规律，诸如门只能旋转90° 上午失败了。下午做成功了~ cSharp写手柄交互 12345678910111213141516171819202122232425262728293031323334using System.Collections.Generic;using UnityEditor.Build.Reporting;using UnityEngine;using UnityEngine.XR;using UnityEngine.XR.Interaction.Toolkit;public class PlayBall : MonoBehaviour{ public XRController leftController; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { Vector2 result; //创建了一个二维向量 var success = leftController.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxis, out result); //检测左手设备摇杆 （第一个参数是他的轴 按键摇杆の位置，第二个是给result赋值 out就是说这个值是通过这个方法里面来给他进行赋值的） // var success 并且会返回一个布尔值 假如调用成功了就true 失败就失败了 if (success) { //成功获取了偏移量就会触发这个函数 var position = transform.position; transform.position = new Vector3(position.x + result.x, position.y, position.z + result.y); //y轴是向上的轴，所以是原来的即可 } }}","link":"/2022/09/12/PicoVR%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%202/"},{"title":"Rider编辑器取消右边白条","text":"🚀 JB社的这个设计看着真的很烦人欸 按下Ctrl+Alt+S 在出现搜索框内输入👇 Show hard wrap and visual guides 将其取消勾选 即可取消界面上的白线 | 我已经不是微软粉了，我现在只会尬黑微软，JB社才是宇宙无敌之好用之666","link":"/2022/10/15/Rider%E7%BC%96%E8%BE%91%E5%99%A8%E5%8F%96%E6%B6%88%E5%8F%B3%E8%BE%B9%E7%99%BD%E6%9D%A1/"},{"title":"Three 探索 01","text":"🌂 要在浏览器中显示 3D 模型，在 Three.js 中需要以下的基本元素： 場景（Scene）：供其他元素設置的空間。相機（Camera）：在場景中建立觀察點，並確定觀察方向、角度。物體（Objects）：在場景中添加被觀察的物體。光源（Light）：在場景中用來照亮物體的光。渲染器（Renderer）：將所要呈現的場景渲染到畫面上。 12345678910111213141516171819202122232425262728293031323334353637383940//创建舞台const scene = new THREE.Scene()//🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝//创建一个几何体，它包含材料const geometry = new THREE.BoxGeometry(1, 1, 1)const material = new THREE.MeshBasicMaterial({ color: 0xff0000})//几何体是不能被渲染的，只有几何体和材质结合成网格才能被渲染到屏幕上const mesh = new THREE.Mesh(geometry, material)scene.add(mesh)//🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝//面积const sizes = { width: 800, height: 600}//创建相机 这个参数1我们称之为视野 参数2称之为宽高比const camera = new THREE.PerspectiveCamera(75,sizes.width/sizes.height)//调整相机位置camera.position.z=4camera.position.x=1.5scene.add(camera)//🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝// 创建渲染器const canvas = document.querySelector('.webgl')const renderer = new THREE.WebGLRenderer({ canvas:canvas})renderer.setSize(sizes.width,sizes.height)renderer.render(scene,camera) 相机位置变化","link":"/2022/08/07/Three%20%E6%8E%A2%E7%B4%A2%2001/"},{"title":"Three 探索 02","text":"🌙 几何基类 Box 立方体 Circle 圆 Cone 圆锥 Cylinder 圆柱 Dodecahedron 十二面体 Icosahedron 二十面体 Octahedron 八面体 Plane 二维平面 Sphere 🌏 Tetrahedron 四面体 Torus 环面 TorusKnot 花托结 构建几何の类 Edges 边缘 Extrude 挤出 Lathe 车床 Parametric 参数化（可变） Shape 形状 Text 文本 Tube 立方体 lineTo和moveTo的区别MoveTo 不画线LineTo 画线,还移动.一般都是MoveTo一个地方,再 LineTo另一个地方,就把这两点连起来了 position 位置scale 缩放rotation 旋转quaternion 四位元","link":"/2022/08/04/Three%20%E6%8E%A2%E7%B4%A2%2002/"},{"title":"Three 探索 03","text":"🗡 这一节我接触了Webpack 12vue-cli 内部用的 是 webpack 运行在 node 环境vite 运行在 浏览器环境，依赖 es6模块化 node 语法，直接在 vite里面 跑，会报错~ 首先安装Node环境 Webpack支持从js里导入css文件但原生的js就无法做到 并且允许直接引入npm库的在线JS库，哦这真的很好用 1234import './style.css'import * as THREE from 'three'console.log(THREE.PerspectiveCamera);//我可没有安装three，但是依然可以引用成功 位置的改变应该放在 渲染器正式工作之前 向位置传递数据 使用物体.position.distanceTo(一个向量) 重置坐标物体.position.normlize() 设置物体的坐标有两种方法物体.position.x = 一个数物体.position.set(x（数）,y,z) 显示xyz坐标轴new THREE.AxesHelper() 绕着X轴旋转：物体.rotation.x（逆时针）旋转通常结合 Math.PI 多个旋转调整xyz旋转的工作顺序物体.rotation.reorder(‘YXZ’) Threejs 相机对象 Camera 的 .lookAt() 方法用来设置相机对象看向的位置，比如在Threejs三维场景中通过相机对象.lookAt()方法指向场景中的一个球体，球体渲染出来后会显示在Canvas画布的正中间，.lookAt() 方法就是旋转相机对象以面向世界空间中的某个点，本质上改变的是相机对象的视图矩阵，具体点说是视图矩阵的旋转部分， 模块化 使用new Group()可以把一堆东西封装在一个group同时调用 动画最初的目的是调用函数 12window.requestAnimationFrame(函数名字不带括号)//这是原生JS 动画循环的函数 gsap动画库 12gsap.to(mesh.position,{duration:1,delay:1,x:2})//第一个参数物体的原位置，{持续，延迟，目的位置}","link":"/2022/08/08/Three%20%E6%8E%A2%E7%B4%A2%2003/"},{"title":"Three 探索 05","text":"🐉 12345678910111213const tick = () =&gt; { camera.position.x = Math.sin(cursor.x * 2 * Math.PI) * 3 camera.position.z = Math.cos(cursor.x * 2 * Math.PI) * 3 camera.position.y = cursor.y *5 //括号内的是一个角度，是相机围绕一个物体运动（360°围绕） camera.lookAt(mesh.position) // Render renderer.render(scene, camera) // Call tick again on the next frame window.requestAnimationFrame(tick)} 控制事件 最常用，最经典的控制视角的角度【轨道控制】 1import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls' 引入直接new一个对象并传入参数即可（参数1：相机，参数2：你的canvas）canvas参数是你document.querySelector(‘canvas.webgl’)获得dom的画布 假如想更改这个控制的target 必须要放进tick函数内每帧渲染 开启浅进浅出的效果控制.enableDamping = true","link":"/2022/08/10/Three%20%E6%8E%A2%E7%B4%A2%2005/"},{"title":"Three 探索 04","text":"📷 透视相机 123456let camera = new THREE.PerspectiveCamera(视野，宽高比,...)//请留意 数值数值越大，您看到的物体也就越小，同时可以看见的东西会变多 这很符合客观世界//函数总共有四个参数，分别是fov，aspect，near，far 。fov表示摄像机视锥体垂直视野角度，最小值为0，最大值为180，默认值为50，实际项目中一般都定义45，因为45最接近人正常睁眼角度；aspect表示摄像机视锥体长宽比，默认长宽比为1，即表示看到的是正方形，实际项目中使用的是屏幕的宽高比；near表示摄像机视锥体近端面，这个值默认为0.1，实际项目中都会设置为1；far表示摄像机视锥体远端面，默认为2000，这个值可以是无限的，说的简单点就是我们视觉所能看到的最远距离。//除了上述四个基本属性之外，透视投影相机六个属性，分别是：filmGauge，filmOffset，focus，isPerspectiveCamera，view，zoom。这几个参数在实际应用中很少用到，基本都保持默认值// 正交相机 123456789101112131415161718const camera = new THREE.OrthographicCamera(-1,1,1,-1,.1,100)//left, right, top, bottom, near, far //这些数值越大物体反而变小//left：左面，即以摄像机（初始相机）所在点为原点，向左的最大距离。//right：右面，即以摄像机（初始相机）所在点为原点，向右的最大距离。//top：上面，即以摄像机（初始相机）所在点为原点，向上的最大距离//bottom：下面，即以摄像机（初始相机）所在点为原点，向下最大距离。//near ：渲染起点。以摄像机（初始相机）所在点为原点，垂直于left\\right\\top\\bottom构成的十字坐标系，从距离原点什么位置开始进行渲染。//far：渲染重点。以摄像机所在点为原点，垂直于left\\right\\top\\bottom构成的十字坐标系，到距离原点什么位置结束渲染。//也就是说，6个参数都是相对于原点的长度，而不是模型的最大坐标点和最小坐标点即 渲染的是一个场面 ，往左往右这些数值越大物体反而变小","link":"/2022/08/09/Three%20%E6%8E%A2%E7%B4%A2%2004/"},{"title":"Three 探索 06","text":"🛏 自适应渲染窗口大小 这里使用的原生JS 1234567891011window.addEventListener('resize',()=&gt;{ sizes.width = window.innerWidth sizes.height = window.innerHeight //相机更新 camera.aspect =sizes.width/sizes.height camera.updateProjectionMatrix() //画布更新 renderer.setSize(sizes.width, sizes.height)}) 像素绘制比率 只需要在加一句 12renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)) 全屏 退出全屏它可以是画布 或者视频值得注意的是 苹果safari浏览器需要单独设置 12345678910111213141516171819202122232425//这里是双击全屏window.addEventListener('dblclick',()=&gt;{const fullscreenElement = document.fullscreenElement || document.webkitfullscreenElement //如果没有全屏if(!fullscreenElement){ //👇这两个判断是判断浏览器是什么内核，如果是苹果浏览器他将走下面的，本质是为了兼容性 if(canvas.requestFullscreen){ canvas.requestFullscreen() } else if(canvas.webkitfullscreenElement){ canvas.webkitrequestFullscreen }}//如果目前处于全屏else{ document.exitFullscreen()}})","link":"/2022/08/11/Three%20%E6%8E%A2%E7%B4%A2%2006/"},{"title":"Unity Assetbundle","text":"🎮 Assetbundle资源打包、加载、卸载资源打包打包素材标签名字格式 小写 “文件名+unity3d” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections;using System.Collections.Generic;using UnityEngine;using System.IO;using UnityEditor;public class ABTools{ //打包的核心方法 private static void BuildAssetBundle(BuildTarget buildTarget) { // 1. 确定资源打包的文件夹里面 ⭐ string backOrignFold = Application.dataPath + &quot;/../../Release/&quot;; string assetFold = backOrignFold + buildTarget + &quot;/StreamingAssets/&quot;; // 2. 对文件的逻辑 如果文件夹存在则会删除，并重新创建 if (Directory.Exists(assetFold)) { Directory.Delete(assetFold, true); // 第一个参数是检测的目录，第二个参数是要不是删除掉 } Directory.CreateDirectory(assetFold); // 3. 往这个目录里打包文件 BuildPipeline.BuildAssetBundles(assetFold, BuildAssetBundleOptions.None, buildTarget); //BuildPipeline.BuildAssetBundle已经被弃用 } #region Platform 执行打包 [MenuItem(&quot;打包工具/PC&quot;)] public static void buildAB_PC() { BuildAssetBundle(BuildTarget.StandaloneWindows); } [MenuItem(&quot;打包工具/Android&quot;)] public static void buildAB_Android() { BuildAssetBundle(BuildTarget.Android); } [MenuItem(&quot;打包工具/iOS&quot;)] public static void buildAB_iOS() { BuildAssetBundle(BuildTarget.iOS); } #endregion} manifest日志文件 包含了素材的一些基本信息 加载视频 或者是任何的资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.Video;public class ABManager : MonoBehaviour{ // 1 确定资源被打包的路径 private string asset; void Start() { asset = Application.dataPath + &quot;/../../Release/StandaloneWindows/StreamingAssets/&quot;; //播放视频 从AB中加载视频源 #region 加载资源 ⭐ LoadVideoFromAB(); LoadUIFromAB(); LoadAudioFromAB(); #endregion } void LoadVideoFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;cg.unity3d&quot;); // 3 从AB中在加载资源 VideoClip clip = ab.LoadAsset&lt;VideoClip&gt;(&quot;cg.mp4&quot;); VideoPlayer video = GameObject.Find(&quot;Canvas/RawImage&quot;).GetComponent&lt;VideoPlayer&gt;(); video.clip = clip; video.Play(); } void LoadUIFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;bg1.unity3d&quot;); // 3 从AB中在加载资源 Sprite sprite = ab.LoadAsset&lt;Sprite&gt;(&quot;bg1.jpg&quot;); Image image = GameObject.Find(&quot;Canvas/Image&quot;).GetComponent&lt;Image&gt;(); image.sprite = sprite; } void LoadAudioFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;bgaudio.unity3d&quot;); // 3 从AB中在加载资源 AudioClip clip = ab.LoadAsset&lt;AudioClip&gt;(&quot;bgaudio.wav&quot;); AudioSource audio = transform.GetComponent&lt;AudioSource&gt;(); audio.clip = clip; audio.Play(); }} 加载 prefab ＆ scene打包好的𝙥𝙧𝙚𝙛𝙖𝙗预制体依赖许多文件 包括网格、贴图、材质球等，如果直接加载是会丢失的，因此需要先把模型的依赖文件先加载出来，再产卵 代码如下👇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;using UnityEngine.UI;using UnityEngine.Video;public class ABManager : MonoBehaviour{ // 1 确定资源被打包的路径 private string asset; void Start() { asset = Application.dataPath + &quot;/../../Release/StandaloneWindows/StreamingAssets/&quot;; //播放视频 从AB中加载视频源 #region 加载资源 // LoadVideoFromAB(); // LoadUIFromAB(); // LoadAudioFromAB(); //加载依赖项 GetAllDependencies(&quot;monster.unity3d&quot;); //加载预制体 // LoadPrefabsFromAB(); #endregion } void LoadVideoFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;cg.unity3d&quot;); // 3 从AB中在加载资源 VideoClip clip = ab.LoadAsset&lt;VideoClip&gt;(&quot;cg.mp4&quot;); VideoPlayer video = GameObject.Find(&quot;Canvas/RawImage&quot;).GetComponent&lt;VideoPlayer&gt;(); video.clip = clip; video.Play(); } void LoadUIFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;bg1.unity3d&quot;); // 3 从AB中在加载资源 Sprite sprite = ab.LoadAsset&lt;Sprite&gt;(&quot;bg1.jpg&quot;); Image image = GameObject.Find(&quot;Canvas/Image&quot;).GetComponent&lt;Image&gt;(); image.sprite = sprite; } void LoadAudioFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;bgaudio.unity3d&quot;); // 3 从AB中在加载资源 AudioClip clip = ab.LoadAsset&lt;AudioClip&gt;(&quot;bgaudio.wav&quot;); AudioSource audio = transform.GetComponent&lt;AudioSource&gt;(); audio.clip = clip; audio.Play(); } public void LoadPrefabsFromAB() { // 2 加载AssetBundle AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;monster.unity3d&quot;); // 3 从AB中在加载资源 GameObject go = ab.LoadAsset&lt;GameObject&gt;(&quot;monster.prefab&quot;); GameObject go1 = GameObject.Instantiate(go); go1.transform.position = Vector3.zero; } public void LoadSceneFromAB() { AssetBundle ab = AssetBundle.LoadFromFile(asset + &quot;mobascene.unity3d&quot;); SceneManager.LoadScene(&quot;mobascene&quot;); } private AssetBundle mainAB; private AssetBundleManifest mainfest; //🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝👇核心部分 void GetAllDependencies(string ABName) { if (mainAB == null) { mainAB = AssetBundle.LoadFromFile(asset + &quot;StreamingAssets&quot;); } if (mainfest == null) { mainfest = mainAB.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;); } //通过这个方法可以获取到它所依赖的资源 是一个数组 string[] dependencies = mainfest.GetAllDependencies(ABName); if (dependencies.Length &gt; 0) { foreach (var item in dependencies) { AssetBundle ab = AssetBundle.LoadFromFile(asset + item); ab.LoadAllAssets(); //这就把每个资源都加载出来了 } } }} 资源的卸载AssetBundle加载的文件都会被清理掉为了释放内存，一般用在场景切换 12345678910111213private void Update() { if (Input.GetKeyDown(KeyCode.A)) { //卸载所有的AB 以及通过AB加载出来的资源 AssetBundle.UnloadAllAssetBundles(true); } else if (Input.GetKeyDown(KeyCode.S)) { //卸载掉未引用的包 比较安全 AssetBundle.UnloadAllAssetBundles(false); } } 测试只能使用一次，也就是说内存中将不存在","link":"/2022/12/28/Unity%20Assetbundle/"},{"title":"Unity HDRP 1","text":"🎮 天空 和 雾量默认的天空盒为空，可以去商店找一些喜欢的 雾的设置增加场景体积、添加光亮、反射率 HDRP设置光记录🐟Unity 灯光系统 相机添加一些效果先修改抗锯齿在主相机里修改 叫Post Anti-aliasing","link":"/2023/01/05/Unity%20HDRP%201/"},{"title":"Unity ILRuntime","text":"🎮 环境配置 123456&lt;linker&gt; &lt;assembly fullname=&quot;Unity.Model&quot; preserve=&quot;all&quot; /&gt; &lt;assembly fullname=&quot;Unity.ThirdParty&quot; preserve=&quot;all&quot; /&gt; &lt;assembly fullname=&quot;UnityEngine&quot; preserve=&quot;all&quot; /&gt; &lt;assembly fullname=&quot;System&quot; preserve=&quot;all&quot; /&gt;&lt;/linker&gt; link.xml 标记了在打包的时候哪些文件类型不被剔除掉 建议创建的脚本最好放到 Hotfix 下 或者 Model 下 要么 放到 ThirdPart 下 有相关的dll文件可以把依赖文件留着 以后项目也能用 ILRuntime 的实现原理ILRuntime借助Mono.Cecil库来读取DLL的PE信息，以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解译执行虚拟机来执行DLL中的代码。 扩展接口12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using System.IO;using UnityEditor;using UnityEngine;//Unity提供的特性 每次编译完脚本都会执行 也就是说启用编辑器就会执行👇[InitializeOnLoad]public class BuildHotfixEditor{ private const string scriptAssembliesDir = &quot;Library/ScriptAssemblies&quot;; //复制到哪个文件夹 private const string codeDir = &quot;Assets/Res/Code/&quot;; //hotfixdll的文件夹 const string hotfixDll = &quot;Unity.Hotfix.dll&quot;; //hotfixpdb的文件夹 const string hotfixPdb = &quot;Unity.Hotfix.pdb&quot;; //⭐ static BuildHotfixEditor() { File.Copy(Path.Combine(scriptAssembliesDir,hotfixDll),Path.Combine(codeDir,hotfixDll+&quot;.bytes&quot;),true); File.Copy(Path.Combine(scriptAssembliesDir,hotfixPdb),Path.Combine(codeDir,hotfixPdb+&quot;.bytes&quot;),true); Debug.Log(&quot;复制hotfix文件成功&quot;); AssetDatabase.Refresh(); //👆这代码就是相当于在面板刷新了一下，让新的素材显露出来 }} Unity主工程 和 热更新工程 的交互12345678910111213void Start() { Load(); CallStaticFunction(); } void CallStaticFunction() { //调用没有带参数 appDomain.Invoke(&quot;Unity.Hotfix.Init&quot;, &quot;Log&quot;,null,null); appDomain.Invoke(&quot;Unity.Hotfix.Init&quot;, &quot;Log&quot;,null,&quot;Hello ILR!&quot;); appDomain.Invoke(&quot;Unity.Hotfix.Init&quot;, &quot;Log&quot;,null, new string[]{&quot;hello&quot;,&quot;ilr&quot;}); } 所调用的函数区域👇或许是”重载”由参数自动匹配 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;//⭐namespace Unity.Hotfix{ public class Init { static void Log() { Debug.Log(&quot;Log1被调用了&quot;); } static void Log(string text) { Debug.Log(&quot;Log1被调用了&quot;+text); } static void Log(string str1,string str2) { Debug.Log(&quot;Log1被调用了&quot;+str1+&quot;:&quot;+str2); } }}","link":"/2022/12/31/Unity%20ILRuntime/"},{"title":"Unity Light 1","text":"🎮 让物体发光 像霓虹灯那样 font{ background: linear-gradient(to right, red, blue); -webkit-background-clip: text; color: transparent; } 静态烘培前期准备 将场景内的一切都删除 包括相机 包括光，包括天空盒子 核心步骤 选中要烘焙的物体，右上角那个设置为GI、在光里面选择base 然后在rendering里面烘焙 烘培后的东西不要移动了，因为都变成静态的信息了mixed 不能删灯光 （旋转光可以改变）base 可以删runtime 实时参与 新建一个灯光设置 在 lighting内的 scene新建new… 取消compress lightmaps 贴图质量会好很多勾选AO 记得模型导入时候要勾选某个东西（因为图片挂了导致没办法显示，总之记得要勾选） HDRP设置光🐟Unity HDRP⌨ 选中灯光对象，里面有常用的设置，包括阴影质量、体积光","link":"/2023/01/05/Unity%20Light%201/"},{"title":"Unity Particle 1","text":"🎮 Unity 粒子系统API 官方手册🚪https://docs.unity3d.com/cn/2020.3/Manual/ParticleSystemModules.html","link":"/2022/12/15/Unity%20Particle%201/"},{"title":"Unity Record 1","text":"🎮 让 Scene窗口 与 Game窗口 的摄像机视角一致先选中主相机 再按Ctrl+Shift+F Unity 里的脚本名不能重名 Math.Round( X.XXX , 几 )保留几位小数 会四舍五入 Math.Floor( X.XXX * 几 ) / 几保留几位小数不会四舍五入 留意：如果保留两位小数，这个几应该是100 变量赋值赋值给一个变量时不要一步到位最多给到某个组件，不要具体到某个属性 在一个c#脚本中 最好是只把变量放在头部 赋值的话放在Start() 让Image和Game窗口一样大先点stretch按住Alt键并点击右下角 拷贝文件Copy(String, String) 将现有文件复制到新文件。 不允许覆盖同名的文件。 Copy(String, String, Boolean) 将现有文件复制到新文件。 允许覆盖同名的文件。","link":"/2022/12/31/Unity%20Record%201/"},{"title":"Unity Shader 1","text":"👾 Shader是描述像素点渲染的一段小程序 名称 发明者 特性 语言 OpenGL SGI 跨平台 GLSL DX 微软 性能非常好👊但只在Windows上用 HLSL CG 微软和英伟达🖕 跨平台 基于C语音，性能也不擦 CG语言 Unity Shader 语言以上三种都支持 还有一个自己的shader语言叫 shaderLab一般就是选择CG和Lab 其他都大同小异 Shader 分类 fixed shader：1.0 开关式，有就能用，没太多的编程能力 顶点 片段着色器：2.0 可自定义 surface shader : 3.0 前两种的封装，可以达到次世代级别 OpenGL渲染流程 #任何的显卡显示器、图片、媒体、游戏等等都会遵守这个流程丶 材质球👉人的衣服 shader👉决定衣服材质怎么跟光进行计算 反射等等 定义一个变量： name（“display name”，Int） = number， name：变量名字。一般以下划线开头 displayname 供外界使用的参考说明 Int 表示类型 number 表示默认值 3d纹理类型用的不太多，默认值经常为空","link":"/2023/01/10/Unity%20Shader%201/"},{"title":"Unity Shader Graph 1","text":"🎮 Texture2DVertex决定图形移动方式 Fragment决定外观，像颜色、透明度","link":"/2023/01/07/Unity%20Shader%20Graph%201/"},{"title":"Unity UGUI 1","text":"🎮 UGUI其实平常学习中就经常使用在一个普通3D项目中，编辑和学习UI相关内容时选择2D模式，工具选择方框 就可以拖动UI了 外边的白框是屏幕范围 六大基础组件👇 三大渲染模式 Screen Space-Camera 模式下 Render Camera不要用主相机 往往新建一个专门显示UI的摄像机（最前层） 画面是二者结合 但是world space下一般是用主相机渲染 做手游，用第二种模式用的最多 相关插件 Ugui 源码目录 视频回顾👇 3-Canvas_哔哩哔哩_bilibili","link":"/2022/11/22/Unity%20UGUI%201/"},{"title":"Unity 代码获取物体","text":"🎮 Unity的几种查找物体的方式按标签 按名称 按组件 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; public class FindObj : MonoBehaviour{ void Start() { print(&quot;按名称： &quot; + GameObject.Find(&quot;name--01&quot;).name); //name--01是游戏物体的面板名字 print(&quot;按标签（单个）： &quot; + GameObject.FindGameObjectWithTag(&quot;tag&quot;).name); //查找到结果为所有符合的物体返回数组 GameObject[] Objs; Objs = GameObject.FindGameObjectsWithTag(&quot;tag&quot;); for (int i = 0; i &lt; Objs.Length; i++) { print(&quot;按标签（多个）： &quot; + Objs[i].name); } //查找到结果为所有符合的物体返回单个数据 Button findObj = (Button)GameObject.FindObjectOfType(typeof(Button)); print(&quot;按类型查找（单个）： &quot; + findObj.name); //查找到结果为所有符合的物体返回数组 Button[] findObjs = (Button[])GameObject.FindObjectsOfType(typeof(Button)); for (int i = 0; i &lt; findObjs.Length; i++) { print(&quot;按类型查找（多个）： &quot; + findObjs[i].name); } }} 获取子物体3种办法1.GetComponentsInChildren() 这个是获取所有子物体（包括父物体）的方法。 123456789Transform[] myTransforms = GetComponentsInChildren&lt;Transform&gt;();foreach (var child in myTransforms){ Debug.Log(child.name);} 2.transform.Find() 此方法通过名字寻找特定子物体，只能寻找一级子物体，不能寻找二级子物体 1Debug.Log(transform.Find(&quot;Child0&quot;));//一级子物体 所以此方法适用于：只寻找一级子物体 3.transform.GetChild() 此方法是根据子物体的序号来获取子物体，只能获取一级的子物体，但是可以通过连续两次获取，获取到二级的子物体。","link":"/2022/12/15/Unity%20%E4%BB%A3%E7%A0%81%E8%8E%B7%E5%8F%96%E7%89%A9%E4%BD%93/"},{"title":"Unity 定时器","text":"🎮 定时器 关键在于如何去理解Time.deltaTime【时间的流逝】🥁 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SocialPlatforms;public class Emitter : MonoBehaviour{ public GameObject cube; public GameObject[] emitter; public Material[] cubeMaterials; public float timer = 1.0f; void Start() { } // Update is called once per frame void Update() { timer -= Time.deltaTime; if (timer &lt; 0) { Vector3 cubePosition = emitter[Random.Range(0, 4)].transform.position; Instantiate(cube); cube.transform.position = cubePosition; cube.GetComponent&lt;MeshRenderer&gt;().material = cubeMaterials[Random.Range(0, 4)]; timer = 2.0f; print(&quot;1&quot;); } }}","link":"/2022/09/12/Unity%20%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"title":"Unity 打字机对话系统","text":"🖨 整体思路 把剧本放在文本文件中 支持的文件格式如👇 是以指定某个字符进行切割 一般都是换行字符 👉(‘ \\n ‘)（请留意是单引号） 并再指定一个空的列表把每个切割好的字符串排进此列表 然后再来个内部循环 把将列表的字符串每个字打印出来 以协程控制打印速度 初始版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374using System;using System.Collections;using System.Collections.Generic;using System.Net.Mime;using UnityEngine;using UnityEngine.UI;public class DialogSystem : MonoBehaviour{ public TextAsset dialogsFile; public int index; private Transform textObject; private Text dialog; private List&lt;string&gt; textList = new List&lt;string&gt;(); private void Awake() { InitTextFile(dialogsFile); } //这是一个字符列表 private void OnEnable() { 🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈 //一开启就显示第一行 dialog.text = textList[index]; index++; 🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈 } void Start() { } // Update is called once per frame void Update() { if (Input.GetKeyDown(KeyCode.J) &amp;&amp; index == textList.Count) { gameObject.SetActive(false); index = 0; return; } if (Input.GetKeyDown(KeyCode.J)) { 🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈 dialog.text = textList[index]; index++; 🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈🍈 //进阶版的就是在此基础上做修改 } } //初始化 void InitTextFile(TextAsset dialogsFile) { textList.Clear(); index = 0; //先清零,包括列表文本和下标 textObject = transform.GetChild(0); dialog = textObject.GetComponent&lt;Text&gt;(); //----------------------------------------------------------------------- var lineData = dialogsFile.text.Split('\\n'); //是以回车键切割,并将所有的都存进lineData foreach (var line in lineData) { textList.Add(line); //将每行存进列表 } }} 进阶 StartCoroutine()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112using System;using System.Collections;using System.Collections.Generic;using System.Net.Mime;using UnityEngine;using UnityEngine.UI;public class DialogSystem : MonoBehaviour{ public TextAsset dialogsFile; public float playTextSpeed; public int index; private Transform textObject; private Text dialog; private List&lt;string&gt; textList = new List&lt;string&gt;(); private bool notTyping; private void Awake() { InitTextFile(dialogsFile); } //这是一个字符列表 private void OnEnable() { //🍎来限定打字是否完成，不然会出乱码 notTyping = true; //🍎来限定打字是否完成，不然会出乱码 //一开启就显示第一行 // dialog.text = textList[index]; // index++; StartCoroutine(PlayText()); } // Update is called once per frame void Update() { if (Input.GetKeyDown(KeyCode.X) &amp;&amp; index == textList.Count) { gameObject.SetActive(false); index = 0; return; } //🍎 if (Input.GetKeyDown(KeyCode.X) &amp;&amp; notTyping) { // dialog.text = textList[index]; // index++; StartCoroutine(PlayText()); } } //初始化 void InitTextFile(TextAsset dialogsFile) { textList.Clear(); index = 0; //先清零,包括列表文本和下标 textObject = transform.GetChild(0); dialog = textObject.GetComponent&lt;Text&gt;(); //----------------------------------------------------------------------- var lineData = dialogsFile.text.Split('\\n'); //是以回车键切割,并将所有的都存进lineData foreach (var line in lineData) { textList.Add(line); //将每行存进列表 } } IEnumerator PlayText() { //🍎来限定打字是否完成，不然会出乱码 notTyping = false; //🍎来限定打字是否完成，不然会出乱码 dialog.text = &quot;&quot;; //是因为累积起来的dialog都存到一起了 因此务必清零，这一步也把原本文字框的文字给清零了 //🥝字符界定 因为之前的字符串里可能含有转义符号 因此加了.Trim()就可以保留最基本的信息 switch (textList[index].Trim()) { case &quot;A&quot;: print(&quot;A&quot;); index++; //直接略过去; break; case &quot;B&quot;: print(&quot;B&quot;); index++; //直接略过去; break; } //🥝 //核心♥ for (int i = 0; i &lt; textList[index].Length; i++) { dialog.text += textList[index][i]; yield return new WaitForSeconds(playTextSpeed); } //核心♥ index++; //🍎来限定打字是否完成，不然会出乱码 notTyping = true; //🍎来限定打字是否完成，不然会出乱码 }} 最终版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142using System;using System.Collections;using System.Collections.Generic;using System.Net.Mime;using UnityEngine;using UnityEngine.UI;public class DialogSystem : MonoBehaviour{ public TextAsset dialogsFile; public float playTextSpeed; public int index; private Transform textObject; private Text dialog; private List&lt;string&gt; textList = new List&lt;string&gt;(); private bool notTyping, cancelTyping; private void Awake() { InitTextFile(dialogsFile); } //这是一个字符列表 private void OnEnable() { //🍎来限定打字是否完成，不然会出乱码 notTyping = true; //🍎来限定打字是否完成，不然会出乱码 //一开启就显示第一行 // dialog.text = textList[index]; // index++; StartCoroutine(PlayText()); } // Update is called once per frame void Update() { if (Input.GetKeyDown(KeyCode.X) &amp;&amp; index == textList.Count) { gameObject.SetActive(false); index = 0; return; } // //🍎 // if (Input.GetKeyDown(KeyCode.X) &amp;&amp; notTyping) // { // // dialog.text = textList[index]; // // index++; // StartCoroutine(PlayText()); // } #region //直接显示完字 if (Input.GetKeyDown(KeyCode.X)) { if (notTyping &amp;&amp; !cancelTyping) { StartCoroutine(PlayText()); } else if (!notTyping) { cancelTyping = !cancelTyping; } } #endregion } //初始化 void InitTextFile(TextAsset dialogsFile) { textList.Clear(); index = 0; //先清零,包括列表文本和下标 textObject = transform.GetChild(0); dialog = textObject.GetComponent&lt;Text&gt;(); //----------------------------------------------------------------------- var lineData = dialogsFile.text.Split('\\n'); //是以回车键切割,并将所有的都存进lineData foreach (var line in lineData) { textList.Add(line); //将每行存进列表 } } IEnumerator PlayText() { //🍎来限定打字是否完成，不然会出乱码 notTyping = false; //🍎来限定打字是否完成，不然会出乱码 dialog.text = &quot;&quot;; //是因为累积起来的dialog都存到一起了 因此务必清零，这一步也把原本文字框的文字给清零了 //🥝字符界定 因为之前的字符串里可能含有转义符号 因此加了.Trim()就可以保留最基本的信息 switch (textList[index].Trim()) { case &quot;A&quot;: print(&quot;A&quot;); index++; //直接略过去; break; case &quot;B&quot;: print(&quot;B&quot;); index++; //直接略过去; break; } //🥝 //核心♥ #region While int letter = 0; while (!cancelTyping &amp;&amp; letter &lt; textList[index].Length) { dialog.text += textList[index][letter]; yield return new WaitForSeconds(playTextSpeed); letter++; } dialog.text = textList[index]; cancelTyping = false; #endregion // for (int i = 0; i &lt; textList[index].Length; i++) // { // dialog.text += textList[index][i]; // yield return new WaitForSeconds(playTextSpeed); // } //核心♥ index++; //🍎来限定打字是否完成，不然会出乱码 notTyping = true; //🍎来限定打字是否完成，不然会出乱码 }} 请留意：输入设备 👉 Both","link":"/2022/12/15/Unity%20%E6%89%93%E5%AD%97%E6%9C%BA%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F/"},{"title":"Unity 启用插件预览包","text":"🎮 enable preview packages√","link":"/2022/11/18/Unity%20%E5%90%AF%E7%94%A8%E6%8F%92%E4%BB%B6%E9%A2%84%E8%A7%88%E5%8C%85/"},{"title":"Unity 更改编辑器运行时的颜色","text":"🌂 在运行模式下，默认的界面颜色和主题颜色比较类似，运行的时候难以区分所有的设置都是临时的于是，当结束运行 都将恢复到之前的状态，可以在运行时改变界面颜色来区分 更改步骤点击点名的【Edit】-&gt;选择【Preferences…】👉【Colors】-&gt; Playmode tint","link":"/2022/09/07/Unity%20%E6%9B%B4%E6%94%B9%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%A2%9C%E8%89%B2/"},{"title":"Unity 模型场景优化方案","text":"🎮 LOD优化给物体添加一个LOD组件，然后调试 使用第三方插件优化但有些软件收费 利用建模软件内置功能优化 由于减少了面数，通常会牺牲模型精度","link":"/2022/10/15/Unity%20%E6%A8%A1%E5%9E%8B%E5%9C%BA%E6%99%AF%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"},{"title":"Unity 模拟智能","text":"🎮 寻路向量公式Vector = target.position - now.position 将其单位化然后在 Update() 内执行 留意： Vector3.magnitude 标量 Vector3.normalized 矢量 7调整了屏幕尺寸计算最终坐标 相机size 是100 如果屏幕尺寸是16:9的话，那么x 的右坐标计算终点是 100 * 16/9 = 177.7777~ 8向量符号 12transform.Translate(goal.transform.position)//是相当于移动了括号内的坐标的向量 硬加上去的 10 如何走到跟前停下用if语句，暂存一个值检测距离👇 123456789101112131415161718192021using System;using UnityEngine;public class Move : MonoBehaviour{ public GameObject goal; private Vector3 direction; private float speed = .01f; private void Start() { direction = goal.transform.position - transform.position; } private void FixedUpdate() { var distance = Vector3.Distance( transform.position,goal.transform.position); if (distance &gt; 2) transform.Translate(direction * speed, Space.World); }} 11 终点 - 起点 12 显而易见 Vector3.sqrMagnitude() 的数值更大，节省性能 13 点乘 用途👇 验证两个向量是否垂直 两个向量的方向接近度越大越相似 叉乘 用途👇 找法向量 14 计算角度 以上等同于👇 Vector3.Angle(矢量1，矢量2) Unity也提供了 1Vector3.Dot(本体朝向方向, 目标朝向方向); Mathf.Acos() 是求cos的反函数 【某个向量】.magnitude 可以直接算出来它的模 Mathf.Rad2Deg 将弧度数转换为相应的角度数， 在弧度后面乘上Mathf.Rad2Deg就能转换了（弧度一般是一个数π/X） 15 判断朝向等向量问题 unity提供了 1Vector3.Cross(本体朝向方向, 目标朝向方向); 叉乘来判断最优转向角，根据敌人的方位，判断我们应该向什么方向是最快的 总结 简单来说，在两个物体的位置关系判断中。 点乘可以判断出目标物体在我的前方还是后方。大于零在前方，小于零在后方。 叉乘可以判断出目标物体在我的左边还是右边。大于零在右方，小于零在左方。 点乘 多用于找角度 叉乘找法向量、还有证明当前是往左转还是往右转、叉乘算还能算线线交点顺时针为 负逆时针为 正 cosθ = 点乘/模的积 sinθ = 叉乘/模的积 16＆17 修正游戏对象的正脸朝向其实Unity提供了一个好用的函数 transform.LookAt(target) ; 18 以时间为频率，而不是用GPU、CPU Time.realtimeSinceStartup 这个函数用来统计从游戏一开始计时 一般刚体的运动放置在 FixedUpdate() 里 22Vector3.forward 是一个定值，它没有任何意义!它仅仅代表Vector3(0,0,1)，仅此而已 transform.forward 他是一个用来自动对物体旋转值算出前进方向向量的变量。 12345void MyTranslate(Vector3 dir){ transform.position += this.transform.rotation * dir; } transform.rotation是个四元素，表示一个旋转值，后面dir是一个向量，用一个四元素去乘以一个向量，得到的结果是经过四元素旋转之后的向量，以后关于计算角度与向量之间的关系，都可以用这个方法算出来。 炮弹抛物线轨迹 rb.AddForce() 给刚体一个力，因为是一瞬间的，应该放在 Start() 函数内 👇麦克老师也是这样","link":"/2022/12/08/Unity%20%E6%A8%A1%E6%8B%9F%E6%99%BA%E8%83%BD/"},{"title":"Unity 生命周期函数","text":"🎮 优先级 Awake() 当点击play按钮，所有组件载入时将被视为Awake，如果inspector内的该脚本没有启用，但挂载到该游戏物体上依然可以触发 👇 OnEnable() 载入后将被执行一次，事实上它相当于勾选启用该物体 该函数优先级大于Start 👇 Start() 世俗意义上脚本运行后第1个被执行的函数。 和 Awake() 放置顺序无关，它永远慢于Awake() 👇 FixedUpdate() 刚体应该放在这个里面每0.02秒执行一次，而非每一帧执行一次 👇 Update() 最经典的生命周期函数 每一帧运行一次 跟电脑性能有关 👇 LateUPdate() 每一帧运行一次 如果和Update()同时存在，必然是等Update()的第一帧运行后才会执行，是👆面那个函数的跟屁🐛 同样跟电脑性能有关，该函数用的不多 留意 Time.deltaTime() 本帧与上一帧的间隔时间 当游戏物体被禁用时 Awake() 和 Start() 都不会执行，反复禁用开启Awake() 和 Start() 也只会执行一次 OnDestroy() 当游戏对象被禁用(从一开始就被禁用到结束)，Destroy 不会被监听若刚开始被禁用然后启用又禁用，或开始没有禁用，运行之后禁用了，Destroy 还是会被监听 Reset() 只会在inspector面板生效，在挂载时和未播放时点击reset时会触发 在编辑器内生效 OnGUI() 是一个ui系统，严格来说，每当game窗口刷新时候都会执行这里面的代码 OnDisable() 当被取消勾选启用时，会触发 该函数优先级大于OnDestroy 先禁用再销毁 OnDestroy() 当在inspector移除该脚本时触发，同样hierarchy内删除物体时也会触发 建议＆总结Awake() 适合创建游戏对象 Start() 适合获取游戏对象组件 好处👉不会造成指针报错","link":"/2022/11/30/Unity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"},{"title":"Unity启动免重复加载资源","text":"🎮 每次点击运行时，都会重新加载素材，非常耗时间，因此设置这个后就可以秒运行 Unity主界面（在一个2D项目内，3d项目我没找到）👉 左上角Edit 👉 Project Settings 👉Editor👉勾选Enter Play Mode Settings 它的两个子选项 reload domain 重加载域reload scene 重加载场景","link":"/2022/09/26/Unity%E5%90%AF%E5%8A%A8%E5%85%8D%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/"},{"title":"Unity物体移动跳跃代码模板","text":"🎮 平时用的时候稍微改改即可 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour{ // 😄 void Start() { } // 🤭 void Update() { if (Input.GetKeyDown(&quot;space&quot;)) { Debug.Log(&quot;space&quot;); } if (Input.GetKey(&quot;up&quot;) || Input.GetKey(KeyCode.W)) { Debug.Log(&quot;↑&quot;); } if (Input.GetKey(&quot;down&quot;) || Input.GetKey(KeyCode.S)) { Debug.Log(&quot;↓&quot;); } if (Input.GetKey(&quot;left&quot;) || Input.GetKey(KeyCode.A)) { Debug.Log(&quot;←&quot;); } if (Input.GetKey(&quot;right&quot;) || Input.GetKey(KeyCode.D)) { Debug.Log(&quot;→&quot;); } }}","link":"/2022/09/07/Unity%E7%89%A9%E4%BD%93%E7%A7%BB%E5%8A%A8%E8%B7%B3%E8%B7%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"},{"title":"VSCode写Markdown补全嵌入HTML标签","text":"🚀 中间 绿色 的用来做开发，刚好契合了Vue的图标色右边 蓝色 的用来写markdown左边 紫色 的是信仰加成 如此看来、我也是微软粉了🤭 1.按ctrl+shift+p 输入settings.json打开settings.json文件🥝请留意是user那个🥝2.在出现の大括号内添加如下并保存 123,&quot;[markdown]&quot;: { &quot;editor.quickSuggestions&quot;: true} 请留意，其中前边的逗号是分隔符 3.文件👉首选项👉用户片段 输入markdown加入常用的html标签以及触发词，如下 1234567891011121314151617181920212223{&quot;font-red&quot;: { //名字 &quot;prefix&quot;: &quot;red&quot;, // 设置的模板缩写 &quot;body&quot;: &quot;&lt;font color='red'&gt;$1&lt;/font&gt;$2&quot;, //模板内容，$1表示第一个光标位置，按tab光标会移动到$2,$0是最后光标位置 &quot;description&quot;: &quot;红色字体&quot; //模板描述 }, &quot;Print to console&quot;: { &quot;prefix&quot;: &quot;end&quot;, &quot;body&quot;: [ &quot;## END &quot;, &quot; &quot;, &quot;阿拉丁~神灯&quot;, &quot; &quot;, &quot;&lt;div&gt;&quot;, &quot; &lt;img alt=\\&quot;GIF\\&quot; src=\\&quot;https://springbird.oss-cn-beijing.aliyuncs.com/img/mmqrcode1632325540724.png\\&quot; width=\\&quot;280px\\&quot; /&gt;&quot;, &quot; &lt;img alt=\\&quot;GIF\\&quot; src=\\&quot;https://springbird.oss-cn-beijing.aliyuncs.com/img/qrcode_for_gh_cead8e1080d6_344.jpg\\&quot; width=\\&quot;280px\\&quot; /&gt;&quot;, &quot;&lt;/div&gt;&quot; ], &quot;description&quot;: &quot;end output&quot; }} 以上2个是模板🌰","link":"/2022/07/11/VSCode%E5%86%99Markdown%E8%A1%A5%E5%85%A8%E5%B5%8C%E5%85%A5HTML%E6%A0%87%E7%AD%BE/"},{"title":"Unity 纹理渲染格式","text":"⚽ 纹理压缩 首先一定要确保使用了纹理压缩，这不仅能压缩存储空间，同时也会节省运行时的带宽，这是提升性能且节约电池寿命最好的方法之一。纹理压缩的优点是它们会一直处于压缩状态直到它们要被用于某个片段处理操作的时候。 Unity支持各种各样的纹理压缩方法，默认方法是ETC 压缩格式选项介绍如下： 💧ETC作为一种纹理压缩格式支持所有的设备，但是在压缩质量和大小方面被ETC2所取代，尽管ETC很简单并且有广泛的支持，但是它不支持阿尔法（Alpha）通道而且压缩率也不是很理想。 ⭐PVRTC这种纹理压缩格式仅支持PowerVR硬件平台，支持Alpha通道，具有最好的压缩比率和压缩质量，通过高度灵活的配置一定能够满足质量/大小的要求。 ⭐ASTC是一个开源的压缩格式，支持大部分平台，它支持Alpha通道，具有与PVRTC相似的压缩率和可配置性。 💧DXT作为一种压缩格式广泛的被桌面应用所支持，在移动领域由于授权问题，目前只有Nvidia Tegra平台支持 💧ATC则只有高通Adreno平台支持","link":"/2022/11/15/Unity%20%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93%E6%A0%BC%E5%BC%8F/"},{"title":"VSCode文件区的排序方式","text":"🚀 VS Code是我超级喜欢的一款编辑器，但是有些东西藏得比较深修改显示文件顺序文件的排序方式👇在您的 设置 ( 文件 → 首选项 → 设置 ) 搜索:explorer.sortOrder设置的左侧会出现一支小笔。选择要对文件进行排序的方式。有五个选项👇 12345- Default 默认- Mixed 混合- Files first 文件优先- Type 类型- Modified 最近修改","link":"/2022/07/28/VSCode%E6%96%87%E4%BB%B6%E5%8C%BA%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"},{"title":"Vue 快速模板标签","text":"🐉 在新版的VSCode里打vue 不会出现模板了所以记录一下如何实现打vue出现三个工作区用到的是用户自定义片段 文件👉设置👉自定义片段👉输入vue在大括号内输入以下内容 123456789101112131415161718192021222324252627&quot;Print to console&quot;: { &quot;prefix&quot;: &quot;vue&quot;, &quot;body&quot;: [ &quot;&lt;template&gt;&quot;, &quot; &lt;div&gt;$0&lt;/div&gt;&quot;, &quot;&lt;/template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;export default {&quot;, &quot; components: {},&quot;, &quot; props: {},&quot;, &quot; data() {&quot;, &quot; return {&quot;, &quot; };&quot;, &quot; },&quot;, &quot; watch: {},&quot;, &quot; computed: {},&quot;, &quot; methods: {},&quot;, &quot; created() {},&quot;, &quot; mounted() {}&quot;, &quot;};&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;style lang=\\&quot;scss\\&quot; scoped&gt;&quot;, &quot;&lt;/style&gt;&quot; ], &quot;description&quot;: &quot;A vue file template&quot; } 好了，回到App.vue 开始冒险之旅吧 另外提一下 我新买的红轴ikbc 键盘真好用！","link":"/2022/07/30/Vue%20%E5%BF%AB%E9%80%9F%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE/"},{"title":"Vue 探索 01","text":"🚀 请留意执行任务的script标签一定要放在靠下的位置 pre标签 使 代码块 格式化排版 选择器 【.】类选择器 【#】id选择器 v-指令： v-text ：缺点会替换所有，一般使用插值表达式 ，拼接字符串请留意是单引号 12345&lt;span v-text:&quot;messgae1&quot;&gt;&lt;/span&gt;&lt;span v-text:&quot;messgae2+'！！'&quot;&gt;&lt;/span&gt;&lt;span&gt; {{ message +'!!'}} &lt;/span&gt; v-html:类似上面但是可以识别标签 v-on:绑定事件（简化版：@动作=”函数名”）请留意 js代码里的method和el同级 补充：事件修饰符 按键修饰符@keyup.enter 1234567el: '#app', methods:{ 函数1:function(){ console.log(&quot;我真的算Q&quot;)， 函数2:function(){ console.log(&quot;我真的算P&quot;) } 支持的动作有： *click *dblclick 待补充 在Vue中this指的是data中的成员 我的第一个应用：计算器 1234567891011121314151617var app = new Vue({ el: '#app', data: { num: 0 }, methods: { sub: function() { if (this.num &gt; 0) { this.num -= 1 } else { alert(&quot;不能再少了&quot;) } }, add: function() { if (this.num &lt; 10) { this.num += 1 } else { alert(&quot;超过啦&quot;) } } }}) v-show ：显示隐藏dom，并且具有逻辑判断，原理是修改display v-if ：移除增添dom，并且具有逻辑判断，原理是remove，add（性能消耗大） v-bind ：对应JS的操作标签的属性 写法1：【:属性=”{value:Key}”】留意：当Key为真时value才会生效 写法2：【:属性=”{Key？’value’:””}”】三目运算 意思是当Key真时value生效，否则返回空字符串 ↑这里使用写法1有一个疑问：:src=”{value:key}”，不能直接使用变量，写法2可以正常，我猜想是{}的原因，导致无法找到url 我认为写法1{:}只能识别成字符串，变量不好整 v-for =”(it,index) in arr” 其中it是值，index是键， arr是数组 *数组经常结合v-for，是响应式的 v-model ：双向绑定数据 script和dom里的数据有一方改变 全局都会跟着变（便捷获取输入的值）","link":"/2022/07/09/Vue%20%E6%8E%A2%E7%B4%A2%2001/"},{"title":"Vue 探索 02","text":"🔥 请留意：在script标签内一定要加上setup属性这几个都是响应式对象 主要功能是可以实时修改数值，我想大概原理是innerHTML等一系列的封装 reactive 实时更新 引入比ref更好用 不用修改.value而是直接使得数据变化 通常有对象时用reactivewatch监听数据变化 1234567891011121314watch(要监听的数据,(newValue,oldValue)=&gt;{})// 意思是监听一个数据，会触发一个回调函数，会传入新值和旧值，就可以做到变量变化的监听watch(() =&gt; user.name, (newValue, oldValue) =&gt; { console.log('newValue', newValue); console.log('oldValue', oldValue); })// 我就感觉这种写法好邪恶啊// 当使用reactive时watch([msg, () =&gt; user.name], (newValue, oldValue) =&gt; { console.log('newValue', newValue); console.log('oldValue', oldValue);})// 👆同时监听，感觉更邪恶了 @click 引号里不光可以写函数（既可以传参也可以传事件对象：($event:就是你的动作、比如按键盘，点击鼠标)还可以写表达式是同步更新~ 计算属性 computed将数据缓存起来当再次使用时会直接使用而不必消耗性能 在V-指令里可以放 字符串 对象 数组 表达式 三目运算符 变量等等 defineProps组件定义props数据的类型 1import { useRoute, useRouter } from &quot;vue-router&quot;; useRoute用来获取路由的信息 useRouter执行路由的跳转 一般使用.push跳转 vuex 状态管理模式使用之前务必使用npm安装不同的组件之间共享 很多 共同的数据这时候就需要将数据抽离出来 全局的管理 导入👇创建👇导出导出之后在main.js里引入 使用 1234567891011121314151617181920212223242526272829import { createStore } from &quot;vuex&quot;;// 创建一个新的 store 实例const store = createStore({ state() { return { count: 0, }; }, mutations: { increment(state, payload) { state.count += payload; }, }, getters: { totalPrice(state) { return state.count * 98.8; }, }, actions: { asyncAdd(store, payload) { setTimeout(() =&gt; { store.commit(&quot;increment&quot;, payload); }, 1000); }, },});export default store; mutations 是为了修改state里的数值,getters 是为了计算属性actions 异步(AJAX)操作mutationsss 和getters 导入蚂蚁UI有两种方式一种是全局 另一种按需导入antUI,不用全局注册在vite.config.js里","link":"/2022/07/30/Vue%20%E6%8E%A2%E7%B4%A2%2002/"},{"title":"Vue蓝色波浪线解决办法","text":"🌰 VScode开发vue，可以正常运行，但是template第一个标签提示波浪线 解决办法：在 jsconfig.json 中，输入以下内容： 123&quot;vueCompilerOptions&quot;: {&quot;experimentalDisableTemplateSupport&quot;: true}","link":"/2022/07/20/Vue%E8%93%9D%E8%89%B2%E6%B3%A2%E6%B5%AA%E7%BA%BF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Vue项目01 ListToDo","text":"🚀 是我第一个Vue项目，可以说是梦的起点 123456789101112131415161718192021222324252627&lt;style&gt; * { padding: 0; margin: 0; }&lt;/style&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;center&gt; &lt;h1&gt;ToDoList&lt;/h1&gt; &lt;div id=&quot;todolist&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;getMessage&quot; @keyup.enter=&quot;changeList(getMessage)&quot;&gt; &lt;ul v-show=&quot;list.length!=0&quot;&gt; &lt;li v-for=&quot;(v,k) in list&quot; v-if=&quot;{index:isTrue+1}&quot;&gt; &lt;span&gt; {{ k+1+&quot;.&quot; }} &lt;/span&gt; &lt;label&gt;{{ v }}&lt;/label&gt; &lt;button @click=&quot;clearThis(k)&quot;&gt;x&lt;/button&gt; &lt;/li&gt; &lt;div&gt; {{&quot;总共有&quot;+list.length+&quot;条&quot;}}&lt;button @click=&quot;clearAll&quot;&gt;清除所有&lt;/button&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/center&gt;&lt;script src=&quot;./HelloVue.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223let app = new Vue({ el: &quot;#todolist&quot;, data: { list: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打洞洞&quot;], getMessage: &quot;好好学习天天向上&quot;, }, methods: { changeList: function(e) { this.list.push(e) this.isTrueList.push(true) console.log(this.isTrueList) }, clearAll: function() { this.list = [] }, clearThis: function(e) { this.list.splice(e, 1) } }})","link":"/2022/07/10/Vue%E9%A1%B9%E7%9B%AE01%20ListToDo/"},{"title":"Vue项目02 天气查询","text":"🔪 这个属于网络应用首先，Vue比我想象中的简单好用多了先使用axios获取一个列表，v-for指令会自动检测key，只需要写一遍即可代码如下 1234567891011121314151617181920&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;center&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;天知道&lt;/h1&gt; &lt;input type=&quot;text&quot; placeholder=&quot;待输入&quot; v-model=&quot;city&quot; @keyup.enter=&quot;searchWeather(city,reg)&quot; /&gt;&lt;button @click=&quot;searchWeather(city,reg)&quot;&gt;查询&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(v,k) in weatherList&quot;&gt;{{ v.date }} &lt;p&gt;{{v.type}}&lt;/p&gt; &lt;p&gt;{{v.low}}&lt;/p&gt; &lt;p&gt;{{v.high}}&lt;/p&gt; &lt;p&gt;{{v.fengli}}&lt;/p&gt; &lt;p&gt;{{v.fengxiang}}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/center&gt;&lt;script src=&quot;./Main.js&quot;&gt;&lt;/script&gt; 在js中，并不需要过多复杂的函数 1234567891011121314151617181920212223242526272829303132let app = new Vue({ el: &quot;#app&quot;, data: { city: &quot;&quot;, reg: /^[\\u4E00-\\u9FA5]+$/, //正则表达式用来检测是否为中文 weatherList: [], }, methods: { searchWeather(city, reg) { var that = this //that目前是原data替身 if (city.length != 0 &amp;&amp; reg.test(city)) { axios.get('http://wthrcdn.etouch.cn/weather_mini?city=' + city) .then(function(response) { that.weatherList = response.data.data.forecast console.log(that.weatherList[0].date); console.log(that.weatherList); }) .catch(function(err) {}) } else { alert(&quot;请检查输入为空或者输入的是非汉字&quot;); } } }})","link":"/2022/07/10/Vue%E9%A1%B9%E7%9B%AE02%20%E5%A4%A9%E6%B0%94%E6%9F%A5%E8%AF%A2/"},{"title":"Vue项目03 电商系统 主页","text":"🌰 ElementUI各种布局axios在main.js配置请求拦截器 1234567axios.interceptors.request.use((config) =&gt; { //本区域是预处理登录 增加token，并且绑定一令牌[Authorization] config.headers.Authorization = window.sessionStorage.getItem('token') //挂载请求头，这样有权限的请求头就可以调用成功了 //在最后必须return return config}) 生命周期函数在组件创建时就会执行！就是调用已经自定义函数让他执行 1234567SMZQHS(){XXX();}private XXX (){} 左侧UI渲染使用两个v-for渲染所有的一级菜单和二级菜单:key=”item.id”和:index=”item.id” 给标签绑定一个key和index 能够成功渲染动态绑定一定要加【：】自动折叠设置一个布尔值 默认false给折叠按钮绑定一个点击事件点击一下 把布尔值取反再给侧边栏 el-aside 使用三目运算 来改变宽度*如果是false就是200px如果是true就64px实现首页的路由重定向（可以在同一个vue页内嵌套别的vue）在index导入内层vue，并在要嵌套的主页面添加一个children数组，地址为当前目录下的/welecome ，组件是导入的vue文件的小名并在主页面添加一个重定向（当访问home时，将会被重定向到welcome，但是内容是Home包裹着welcome） 123456{ path: '/home', redirect: '/welcome', component: Home, children: [{ path: '/welcome', component: Welcome }], }, 左侧菜单添加路由功能具体使用饿了么UI提供的属性 开启路由模式所跳转的地址的是根据index值决定","link":"/2022/07/09/Vue%E9%A1%B9%E7%9B%AE03%20%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%20%E4%B8%BB%E9%A1%B5/"},{"title":"Vue项目03 电商系统 用户列表","text":"🌰 BUG左侧栏本身就是卡顿一下，然后点击样式不一样排查原因三目表达式那个width前未加冒号激活状态显示高亮按钮添加一个点击事件传递当前的path名，记录在token内在显示区用的是饿了么UI的组件的属性:default-active=’activePath’读取path名activePath在data中定义绘制用户列表的基本UI结构绘制卡片时那个卡片无法正确出现在下方我使用了绝对定位解决获取用户列表数据*总体使用el-table是、来绘制显示用户信息区用法：给大table嵌套数据源 小table-column使用prop=’’实际上给大table绑定一个对象，小table-column是成员是服务器返回的作用域插槽可以切换显示/隐藏，并且可以通过传值来动态改变内容 1234567&lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-table-column label=&quot;状态&quot; prop=&quot;mg_state&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-switch v-model=&quot;scope.row.mg_state&quot;&gt;&lt;/el-switch&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/template&gt; 请留意：Switch也需要按需导入,作用域插槽会覆盖prop属性 操作区域第三个按钮效果提示当鼠标放在第三个按钮上，上方出现弹窗，当鼠标移出，弹窗自动消失则与要改enterable 12345678910111213&lt;el-tooltip effect=&quot;dark&quot; content=&quot;分配角色&quot; placement=&quot;top&quot; :enterable=&quot;false&quot; &gt; &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-setting&quot; size=&quot;mini&quot; &gt;&lt;/el-button&gt; &lt;/el-tooltip&gt;","link":"/2022/07/09/Vue%E9%A1%B9%E7%9B%AE03%20%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%20%E7%94%A8%E6%88%B7%E5%88%97%E8%A1%A8/"},{"title":"Vue项目03 电商系统 登陆","text":"🌰 跨域用token同域用session,cookie 同域：协议&amp;&amp;端口&amp;&amp;主机全都得一致 删掉了一些标签，如果报错需要关闭语法检查在vue.config.js中添加以下但是我把原来的那个也改成false了，但运行成功 1lintOnSave: false 梳理完整后.. .vue后缀分别有三部分分别是模板、行为、样式 用到什么组件需要在element内全局注册 使用第三方UI库 现在main.js中link，然后就可以在Vue.app使用了 表单规则验证首先给整体绑定 :rules=””指定的rule在data方法的return中然后想呈现信息的元素 的标签 绑定 prop=””请留意prop的值是rules的成员变量🌰 123456789101112loginFormRules:{ username:[ //required相当于校验是否为空，就是说不满足第一个，将执行第二个，第三个是当失去聚焦时 { required: true, message: '请输入登录名称', trigger: 'blur' }, { min: 3, max: 10, message: '长度在 3 到 10 个字符', trigger: 'blur' } ], password:[ { required: true, message: '请输入登录密码', trigger: 'blur' }, { min: 6, max: 16, message: '长度在 6 到 16 个字符', trigger: 'blur' } ] } 其中loginFormRules对应的是:rules=””里的两个对象对应prop=””,想在哪显示就绑定哪里 修改ElementUI的input输入框背景颜色和输入框字体颜色 12345678910修改/deep/input::-webkit-input-placeholder { color: #17a1e5; font-size: 15px;}// 改变input框背景颜色/deep/.el-input__inner { background-color: transparent !important; border: 1px solid #1296db;} 因为框架把设定都默认了，可以使用深度选择器 原来《el-XXXXX》 标签本身就是个类名字 重置功能：给父标签定义一个ref 推荐命名以_______Ref为后缀为按钮绑定一个点击事件*当点击触发一个函数👉this.$refs.刚才父标签命名的那个名字.resetFields(); 就会重置效果为：点击重置，清空输入框 校验功能：给父标签定义一个ref 推荐命名以_______Ref为后缀为按钮绑定一个点击事件*当点击触发一个函数👉this.$refs.刚才父标签命名的那个名字.validate(); 如果符合rules（rules和__Ref那个在同一个父标签内）将返回true，和一个obj 网络请求：配置axios 根目录，将路径以及对象{username:xxx,password:xxx}其实就是双向绑定的那组数据 技巧性东西：对象.属性 👇{属性：小名} = 对象 12345login() { this.$refs.loginFormRef.validate(async valid =&gt; { if (!valid) return; const {data:res} = await this.$http.post(&quot;login&quot;, this.loginForm); console.log(res); 其中这个async 和 await 把我整晕了 友好的弹窗提醒：首先在element.js导入Message 并挂载到this方法， 12import { Message } from 'element-ui'Vue.prototype.$message = Message $message 只是一个自定义の合法の名字在vue.app中就可以使用一系列message弹窗了登陆成功之后将token记录下创建一个页面.vue,在路由.js里导入页面.vue验证登录信息用到路由导航守卫：如果用户没有登录，但是直接通过url访问特定页面，需要重新导航到登陆页面 1234567891011121314151617181920const router = new VueRouter({ routes: [ { path: &quot;/&quot;, redirect: &quot;/login&quot; }, { path: &quot;/login&quot;, component: Login }, { path: &quot;/home&quot;, component: Home }, ],});//挂载路由导航守卫router.beforeEach((to, from, next) =&gt; { //to将要访问的路径 //from从原来的页面 //next是一个函数，表示放行 //next() 放行 next('./login')强制跳转 if (to.path === &quot;/login&quot;) return next(); //获取token const tokenStr = window.sessionStorage.getItem(&quot;token&quot;); if (!tokenStr) return next(&quot;/login&quot;); next();});export default router; to👉将要去的那个页面from 👉原来的页面next👉 放行 行为描述：当我输入账号密码，浏览器记录一个token在Storage里，此时检测页面如果需要权限，则需要验证token，如果没有则返回login，有则放行基于token的退出功能销毁本地のtoken核心代码就两行 12345678export default { methods:{ logout(){ window.sessionStorage.clear() this.$router.push(&quot;/login&quot;) } }}; 关闭自动把’’替换成””和关闭自动添加;","link":"/2022/07/09/Vue%E9%A1%B9%E7%9B%AE03%20%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%20%E7%99%BB%E9%99%86/"},{"title":"Web3.0 入门计划","text":"🌏 原地址传送门🚪https://cubic-leaf-731.notion.site/web3-202208-09-1623ccd15c2148a1ae00ed8794d153b1","link":"/2022/11/20/Web3dot0%E5%85%A5%E9%97%A8%E8%AE%A1%E5%88%92/"},{"title":"XR Interaction Toolkit","text":"🎮 主要是一些inspector里对应的功能，全是英文难以记忆 XR Interaction Toolkit研究官方链接：https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit@2.0/api XRRig : 其实就是XR Origin，官网还没改过来，通常连接到XR Rig的基础对象上，并将其存储起来，然后通过移动进行操作。它也被用来偏移相机。 OriginBaseGameObject：根节点，射线移动和转移就是修改这个对象的位置 CameraFloorOffsetObject：设置相机距离地板的高度 TrackingOriginMode：原点空间跟踪模式（PICO不能选择NotSpecified） TrackedPoseDriver: https://docs.unity3d.com/Packages/com.unity.xr.legacyinputhelpers@2.1/api/UnityEngine.SpatialTracking.TrackedPoseDriver.html Device：跟踪设备类型 PoseSource：追踪资源，大部分选择Center TrackingType：姿态跟踪类型，分位置和朝向 UpdateType：刷新类型，选择UpdateAndBeforeRender，能提供最顺滑的姿态追踪和最低时延的设备延迟 XRController:从XR输入子系统将跟踪的输入控制器设备上的特征值解释为XR交互状态，例如Select。此外，它将被跟踪设备的当前姿态值应用于（UnityXR支持多个XRController，比如左手可以同时有一个Ray交互控制器和一个Direct交互控制器，这样可以实现复杂的交互，但要小心各个交互者之间的层级设定） UpdateTrackingType：刷新类型 controllerNode：控制器选择（左右手） EnableInputActions：是否监听输入动作 selectUsage：选择按钮，抓取动作按钮 activateUsage ：激活按钮（选择状态中激活） uipressUsage：ui按下按钮 AxisToPressThreshold：设置上述三个交互按钮的按下最小限制 RotateObjectLeft/Right/In/Out：设置四个方向的按键定义（用来定义移动和旋转射线抓取物品） ModelPrefab：手模预制物，可以自动生成 ModelParent：手模父节点 Model：手模Tnf AnimateModel：动画模块 调用手柄震动函数：SendHapticImpulse(float amplitude, float duration) XR Socket Interactor：用于通过插座定位可交互内容的交互者 InteractionLayerMask：交互层级遮罩，指定可交互的层级 AttachTransform：附加对象 Keep Selected Target Valid：在最初选择一个可交互对象后，即使它不再是有效的目标，也是否继续选择它。（不勾选，抓取的物品要一直保持选中状态，否则就会掉落） Show Interactable Hover Meshes：当交互对象悬停在插座上时，是否显示网格 Socket Active：是否激活插座 Recycle Delay Time：设置移除对象后插座拒绝悬停的时间 XRRayInteractor:用于在远处与可交互对象进行交互的交互器。这是通过光线转换(ray cast)来处理的，它会更新这个交互器的当前有效目标集。 InteractionLayerMask：交互层级遮罩，指定可交互的层级 EnableInteractionWithUIGameObject：交互器是否能影响UI ForceGrab：是否将抓取物品拉到手上 AttachTransform：附加对象 RayOriginTransform：射线原点，朝向也是调它 LineType：射线类型：直线、抛物线、贝塞尔曲线 Raycast Mask：射线可交互的层级，Unity自带的层级类，不勾选的层级，射线会穿透它 HitClosestOnly：是否只交互最近碰撞的物品 AudioEvent：添加触发声音片段 HapticEvents：添加触发震动 InteractorEvents：添加交互事件 XRDirectInteractor:交互器用于直接与接触的交互设备进行交互。这是通过更新此交互器的当前有效目标集的触发器卷来处理的。这个组件必须有一个被设置为触发器的碰撞卷才能工作。 SelectActionTrigger：对控制器输入进行定义，如何确定为select KeepSelectedTargetVailid：当选择一个可交互目标后，即使他不再是有效的目标，仍然能选择他 HideControllerOnSelect：选择状态下是否隐藏控制器 AllowHoveredActivate：是否允许悬浮情况下激活 XR Simple Interactable:最简单的交互对象，只是有一个具体的交互实现，一般用在去对交互事件进行相应，没有实际的交互手段。 Interaction Layer Mask:层掩码允许与交互层掩码与该交互层掩码中的任何层重叠的交互者进行交互。 Custom Reticle：有效时出现在射线尾端的十字线。 Select Mode：是否运行多个交互者和交互对象进行交互 XR Grab Interactable:允许基本“抓取”功能的可交互组件。可以连接到一个选择的交互者，并在遵守物理的同时跟随它（并在释放时继承速度）。 Interaction Layer Mask:层掩码允许与交互层掩码与该交互层掩码中的任何层重叠的交互者进行交互。 Custom Reticle：有效时出现在射线尾端的十字线。 Select Mode：是否运行多个交互者和交互对象进行交互 Movement Type：移动方式选择（如果想让抓取物品保持物理属性，不穿透墙和桌子，这里要选择“速度追踪”） Retain Transform Parent：交互者放下物品后是否还原至原父对象下 TrackPositon：是否追踪交互者的位置 Track Rotation：是否追踪交互者的朝向 Throw On Detach：是否在释放时继承交互者的速度 Force Gravity On Detach：是否强制对象释放时拥有重力 Attach Transform：交互时依附的点（默认设置物品的中心） LocomotionSystem:用于控制对XR Origin的访问。这个系统强制在同一时间只有一个移动供应商可以移动XR原点。这是访问XR Origin受控制的唯一地方，不推荐使用多个LocomotionSystem实例驱动单个XR Origin。 Teleportation Anchor:锚是将用户传送到预先确定的特定位置和/或旋转的远程传送目的地。 Interaction Layer Mask:层掩码允许与交互层掩码与该交互层掩码中的任何层重叠的交互者进行交互。 Custom Reticle：有效时出现在射线尾端的十字线。 Select Mode：是否运行多个交互者和交互对象进行交互 Teleport Anchor Transform：传送目的地的位点。 Match Orientation：定位origin的方式选择 Teleport Trigger：传送触发的时间选择 Teleportation Provider：该远程传送可交互的远程传送提供者将远程传送请求传送 Teleportation Area：区域是一个传送目的地，将用户传送到表面上的指定位置 Interaction Layer Mask:层掩码允许与交互层掩码与该交互层掩码中的任何层重叠的交互者进行交互。 Custom Reticle：有效时出现在射线尾端的十字线。 Select Mode：是否运行多个交互者和交互对象进行交互 Match Orientation：定位origin的方式选择 Teleport Trigger：传送触发的时间选择 Teleportation Provider：该远程传送可交互的远程传送提供者将远程传送请求传送 Continuous Turn Provider：连续旋转提供者 Turn Speed：旋转速度 Input Binding：旋转轴绑定 Controllers：控制器设置 Deadzone Min/Max：能否触发功能的最大值最小值 Snap Turn Provider：步进旋转提供者 Turn Input Source：旋转轴绑定 Controllers：控制器设置 Turn Amount：每次捕捉到信号旋转的值 Dead Zone：触发信号的限制 Activation Timeout：两次激活的时间间隔 Continuous Move Provider：连续移动提供者 Move Speed：移动速度 Forward Source：自定义向前的方向 Input Binding：移动轴绑定 Controllers：控制器设置 Deadzone Min/Max：能否触发功能的最大值最小值","link":"/2022/09/25/XRInteractionToolkit/"},{"title":"麦扣 3DRPG游戏开发教程 1-7集","text":"🎮 升级urp👉插件搜 universal 去除摩尔纹，在渲染管线设置把depth bias拉到最大 🔧 在资源内添加 rendering 👉universal render pipline👉pipline asset（不必重命名，但最好新建个文件夹把他们放在一起） 选择渲染器project settings👉graphics＆quality 的可编辑渲染管线都选择刚刚创建的 至此一个环境配置好了，现在可以导入一些素材 要确保素材支持urp-通用 或者 lwrp-轻量 一些设置 影子渲染 👉在pipline settings内的第一个文件内设置 选择shadow 后期都可以调节，比如对抗锯齿 阴影啊、、不满意的话回来再调 场景的灯光设置 顶点自动吸附 移动时候按住v键 （选择变成那个正方形）ctrl+shift+F 使得game的相机角度和scene的相机角度一致 使用poly brush 创造一个 low poly的风格环境 使用urp选择第二个，留意括号内的说明 管理project 创建一个addon文件 把polybrush这个插件拖拽进去 polybrush的功能 brush mirroring 对称刷 创建多顶点的平面 需要安装一个插件 probuilder progrids 在场景中多一些参考线 烘焙地图 其实就是设置障碍物不可越过等等 第一个脚本 mouse manager 前期准备 //将坐标传进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;[System.Serializable]public class EventVector3 : UnityEvent&lt;Vector3&gt;{}public class MouseManager : MonoBehaviour{ public EventVector3 OnmouseClicked; private RaycastHit hitInfo; //投线碰撞信息 private void Update() { SetCursorTexture(); MouseControl(); } void SetCursorTexture() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); //鼠标的位置与相机的催化剂 if (Physics.Raycast(ray, out hitInfo)) { //切换鼠标贴图 } } void MouseControl() { if (Input.GetMouseButtonDown(0) &amp;&amp; hitInfo.collider != null) { if (hitInfo.collider.gameObject.CompareTag(&quot;Ground&quot;)) { OnmouseClicked?.Invoke((hitInfo.point)); //就可以被面板内的MouseManager检测到，，可以自行寻路 } } }} 请留意要修改一下地面ground 06 改进mouse manager单例模式 123456789101112131415161718192021222324252627using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour{ private NavMeshAgent agent; private void Awake() { agent = GetComponent&lt;NavMeshAgent&gt;(); } private void Start() { MouseManager.Instance.OnMouseClicked += MoveToTarget; //这是一个事件 } void MoveToTarget(Vector3 target) { agent.destination = target; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using System;// using UnityEngine.Events;// [System.Serializable]// public class EventVector3 : UnityEvent&lt;Vector3&gt;public class MouseManager : MonoBehaviour{ // public EventVector3 OnmouseClicked; private RaycastHit hitInfo; public static MouseManager Instance; public event Action&lt;Vector3&gt; OnMouseClicked; private void Awake() { if (Instance != null) { Destroy(gameObject); } Instance = this; } private void Update() { SetCursorTexture(); MouseControl(); } void SetCursorTexture() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); //鼠标的位置与相机的催化剂 if (Physics.Raycast(ray, out hitInfo)) { //切换鼠标贴图 } } void MouseControl() { if (Input.GetMouseButtonDown(0) &amp;&amp; hitInfo.collider != null) { if (hitInfo.collider.gameObject.CompareTag(&quot;Ground&quot;)) { OnMouseClicked?.Invoke((hitInfo.point)); } } }} 以上代码就是在PlayerController注册了一个事件给MouseManager，在MouseManager会一直执行将投线的坐标传入小狗的寻路终点。 修改指针贴图 需要先将图片纹理类型设置成 cursor 先在MouseManager.cs设置图片的变量 类型为Texture2D 之前留了一个鼠标贴图的位置，现在填上 123456switch (hitInfo.collider.gameObject.tag) { case &quot;Ground&quot;: Cursor.SetCursor(target,new Vector2(16,16),CursorMode.Auto); //纹理，锚点，切换模式 break; 07 摄像机跟随和后处理视野 field of view 摄像机离主角的距离 camera distance 需要安装cinemachine （经典的虚拟相机） Body设置为Framing transposer aim设置为 do nothing 然后follow主角 加入迷雾 scene启用 然后去environment启用迷雾 重要增加画质的启用Post Processing 电影滤镜 添加曝光👉color adjustment 调整 post exposure 畸变👉chromatic aberration 景深👉 depth","link":"/2022/10/08/b%E7%AB%99m_studio3drpg1-7/"},{"title":"麦扣 3DRPG游戏开发教程 12-13集","text":"🎮 虚拟相机之FreeLook适用于目前所有的第三人称视角的摄像机 需要把原有的虚拟相机关闭 去修改攻击范围 尽量不要使用hardCode 高亮注释 //TODO: 内容 Rider我是没找到这个插件 敌人的追击 新学了一个API 👉Physics.OverlapSphere() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public enum EnemyStates{ GUARD, PATROL, CHASE, DEAD}[RequireComponent(typeof(NavMeshAgent))]public class EnemyController : MonoBehaviour{ private NavMeshAgent agent; private EnemyStates enemyStates; [Header(&quot;Basic Settings&quot;)] public float sightRadius; private void Awake() { agent = GetComponent&lt;NavMeshAgent&gt;(); } private void Update() { SwitchStates(); } //状态切换机器 void SwitchStates() { //⭐如果发现player 切换到chase⭐ if (FoundPlayer()) { enemyStates = EnemyStates.CHASE; print(&quot;找到玩家&quot;); } //-------------------------- switch (enemyStates) { case EnemyStates.GUARD: break; case EnemyStates.PATROL: break; case EnemyStates.CHASE: break; case EnemyStates.DEAD: break; } }//👇这个函数最终转换成一个判断 bool FoundPlayer() { var colliders = Physics.OverlapSphere(transform.position, sightRadius); foreach (var target in colliders) { if (target.CompareTag(&quot;Player&quot;)) { return true; } } return false; }} 13 敌人可以追着玩家走//更改动画播放 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public enum EnemyStates{ GUARD, PATROL, CHASE, DEAD}[RequireComponent(typeof(NavMeshAgent))]public class EnemyController : MonoBehaviour{ private NavMeshAgent agent; private EnemyStates enemyStates; private Animator anim; [Header(&quot;Basic Settings&quot;)] public float sightRadius; private float speed; public bool isGuard; private GameObject attackTarget; //bool配合动画 private bool isWalk; private bool isChase; private bool isFollow; private void Awake() { anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); speed = agent.speed; } private void Update() { SwitchStates(); SwitchAnimation(); } void SwitchAnimation() { //⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ anim.SetBool(&quot;Walk&quot;,isWalk); anim.SetBool(&quot;Chase&quot;,isChase); anim.SetBool(&quot;Follow&quot;,isFollow); //⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ } //状态切换机器 void SwitchStates() { //如果发现player 切换到chase if (FoundPlayer()) { enemyStates = EnemyStates.CHASE; } //-------------------------- switch (enemyStates) { case EnemyStates.GUARD: break; case EnemyStates.PATROL: break; case EnemyStates.CHASE: //追逐玩家 //在攻击范围内攻击 //配合动画 isWalk = false; isChase = true; agent.speed = speed; if (!FoundPlayer()) { //拉脱回上一个状态 isFollow = false; agent.destination = transform.position; } else { isFollow = true; agent.destination = attackTarget.transform.position; } break; case EnemyStates.DEAD: break; } } bool FoundPlayer() { var colliders = Physics.OverlapSphere(transform.position, sightRadius); foreach (var target in colliders) { if (target.CompareTag(&quot;Player&quot;)) { attackTarget = target.gameObject; return true; } } attackTarget = null; return false; }}","link":"/2022/10/11/b%E7%AB%99m_studio3drpg12-13/"},{"title":"麦扣 3DRPG游戏开发教程 14集","text":"🎮 随机巡逻点绘制攻击范围 OnDrawGizmosSelected()更节约资源 解决怪位置卡死的方法 NavMesh.SamplePosition(点坐标，out 输出点信息，搜索范围，检测的导航层)，这个函数会返回一个bool值，这个bool值表示 能否在范围内搜索到 距离目标点最近的一个导航点，然后将这个导航点的信息放到 输出点信息中。 123456789101112131415void GetNewWayPoint() { float randomX = UnityEngine.Random.Range(-patrolRange, patrolRange); float randomZ = UnityEngine.Random.Range(-patrolRange, patrolRange); // Vector3 randomPoint = new Vector3(transform.position.x + randomX, transform.position.y, // transform.position.z + randomZ); Vector3 randomPoint = new Vector3(guardPos.x + randomX,transform.position.y, guardPos.z + randomZ); //y还是保持它自身的刚体影响，因为地面上有坑坑洼洼 // todo: 可能出现的问题,不能这么简单就得到这个点 // wayPoint = randomPoint; NavMeshHit hit; wayPoint = NavMesh.SamplePosition(randomPoint, out hit,patrolRange,1)?hit.position:transform.position; //这个函数返回一个bool值，√使得怪物的最终点为这个，否则停留于原地 } //让怪走走停停看看 符合巡逻的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public enum EnemyStates{ GUARD, PATROL, CHASE, DEAD}[RequireComponent(typeof(NavMeshAgent))]public class EnemyController : MonoBehaviour{ private NavMeshAgent agent; private EnemyStates enemyStates; private Animator anim; [Header(&quot;Basic Settings&quot;)] public float sightRadius; private float speed; public bool isGuard; private GameObject attackTarget; //⭐⭐⭐怪的巡逻⭐⭐⭐ public float lookAtTime; private float remainLookAtTime; [Header(&quot;Patrol State&quot;)] public float patrolRange; private Vector3 wayPoint; private Vector3 guardPos; //bool配合动画 private bool isWalk; private bool isChase; private bool isFollow; private void Awake() { //自有组件、自有变量放在awake anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); speed = agent.speed; guardPos = transform.position; remainLookAtTime = lookAtTime; } private void Start() { if (isGuard) { enemyStates = EnemyStates.GUARD; } else { enemyStates = EnemyStates.PATROL; GetNewWayPoint(); } } private void Update() { SwitchStates(); SwitchAnimation(); } void SwitchAnimation() { anim.SetBool(&quot;Walk&quot;, isWalk); anim.SetBool(&quot;Chase&quot;, isChase); anim.SetBool(&quot;Follow&quot;, isFollow); } //状态切换机器 void SwitchStates() { //如果发现player 切换到chase if (FoundPlayer()) { enemyStates = EnemyStates.CHASE; } //-------------------------- switch (enemyStates) { case EnemyStates.GUARD: break; case EnemyStates.PATROL: isChase = false; agent.speed = speed * .5f; //判断一下指定的点 如果相同就给一个新的点，不同就往这儿移动 if (Vector3.Distance(wayPoint, transform.position) &lt;= agent.stoppingDistance) { isWalk = false; if (remainLookAtTime &gt; 0) remainLookAtTime -= Time.deltaTime; else GetNewWayPoint(); } else { isWalk = true; agent.destination = wayPoint; } break; case EnemyStates.CHASE: //追逐玩家 //在攻击范围内攻击 //配合动画 isWalk = false; isChase = true; agent.speed = speed; if (!FoundPlayer()) { //拉脱回上一个状态 isFollow = false; if (remainLookAtTime &gt; 0){ agent.destination = transform.position; remainLookAtTime -= Time.deltaTime; } else if (isGuard)⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ { enemyStates = EnemyStates.GUARD; } else { enemyStates = EnemyStates.PATROL; } } else { isFollow = true; agent.destination = attackTarget.transform.position; } break; case EnemyStates.DEAD: break; } } bool FoundPlayer() { var colliders = Physics.OverlapSphere(transform.position, sightRadius); foreach (var target in colliders) { if (target.CompareTag(&quot;Player&quot;)) { attackTarget = target.gameObject; return true; } } attackTarget = null; return false; } // todo: 随机生成一个点 void GetNewWayPoint() { remainLookAtTime = lookAtTime; float randomX = UnityEngine.Random.Range(-patrolRange, patrolRange); float randomZ = UnityEngine.Random.Range(-patrolRange, patrolRange); // Vector3 randomPoint = new Vector3(transform.position.x + randomX, transform.position.y, // transform.position.z + randomZ); Vector3 randomPoint = new Vector3(guardPos.x + randomX, transform.position.y, guardPos.z + randomZ); //y还是保持它自身的刚体影响，因为地面上有坑坑洼洼 // todo: 可能出现的问题,不能这么简单就得到这个点 // wayPoint = randomPoint; NavMeshHit hit; wayPoint = NavMesh.SamplePosition(randomPoint, out hit, patrolRange, 1) ? hit.position : transform.position; //这个函数返回一个bool值，√使得怪物的最终点为这个，否则停留于原地 } private void OnDrawGizmosSelected() { Gizmos.color = Color.blue; Gizmos.DrawWireSphere(transform.position, sightRadius); }}","link":"/2022/10/15/b%E7%AB%99m_studio3drpg14/"},{"title":"麦扣 3DRPG游戏开发教程 15-16集","text":"🎮 15 制作一系列关于数据的ScriptableObject 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;[CreateAssetMenu(fileName = &quot;New Data&quot;, menuName = &quot;Character Stats/Data&quot;)]//这个能帮我们在Create菜单当中创建一个子集的菜单public class CharacterData_SO : ScriptableObject{ //能想到的所有状态都可以罗列出来 [Header(&quot;Stats Info&quot;)] public int maxHealth; public int currentHealth; public int baseDefence; public int currenrDefence;} 保存不需要任何操作 就自动会生成 这便是scriptObject的好处 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using System.Collections;using System.Collections.Generic;using UnityEngine;public class CharacterStats : MonoBehaviour{ public CharacterData_SO characterData; //get 可读 set可写入 #region Read from Data_SO public int MaxHealth { get { if (characterData != null) return characterData.maxHealth; else return 0; } set { characterData.maxHealth = value; } } public int CurrentHealth { get { if (characterData != null) return characterData.currentHealth; else return 0; } set { characterData.currentHealth = value; } } public int BaseDefence { get { if (characterData != null) { return characterData.baseDefence; } else return 0; } set { characterData.baseDefence = value; } } public int CurrentDefence { get { if (characterData != null) { return characterData.currenDefence; } else return 0; } set { characterData.currenDefence = value; } } #endregion} 16攻击相关重复15集的步骤 添加攻击属性，然后在CharacterStats.CS内调用 然后返回unity 去给它赋值 攻击动画系统里一般都是判断trigger 然后在代码里set一下 暴击一般设置两个动画状态 attack （trigger） | 非暴击👉 | Critical （true） Critical （true） | 👈暴击 | Critical （false） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;using Random = System.Random;public enum EnemyStates{ GUARD, PATROL, CHASE, DEAD}[RequireComponent(typeof(NavMeshAgent))]public class EnemyController : MonoBehaviour{ private NavMeshAgent agent; private EnemyStates enemyStates; private Animator anim; private CharacterStats characterStats; [Header(&quot;Basic Settings&quot;)] public float sightRadius; private float speed; public bool isGuard; private GameObject attackTarget; //怪的巡逻 public float lookAtTime; private float remainLookAtTime; private float lastAttackTime; [Header(&quot;Patrol State&quot;)] public float patrolRange; private Vector3 wayPoint; private Vector3 guardPos; //bool配合动画 private bool isWalk; private bool isChase; private bool isFollow; private void Awake() { //自有组件、自有变量放在awake anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); speed = agent.speed; guardPos = transform.position; remainLookAtTime = lookAtTime; characterStats = GetComponent&lt;CharacterStats&gt;(); } private void Start() { if (isGuard) { enemyStates = EnemyStates.GUARD; } else { enemyStates = EnemyStates.PATROL; GetNewWayPoint(); } } private void Update() { SwitchStates(); SwitchAnimation(); lastAttackTime -= Time.deltaTime; } void SwitchAnimation() { anim.SetBool(&quot;Walk&quot;, isWalk); anim.SetBool(&quot;Chase&quot;, isChase); anim.SetBool(&quot;Follow&quot;, isFollow); anim.SetBool(&quot;Critical&quot;,characterStats.isCritical); } //状态切换机器 void SwitchStates() { //如果发现player 切换到chase if (FoundPlayer()) { enemyStates = EnemyStates.CHASE; } //-------------------------- switch (enemyStates) { case EnemyStates.GUARD: break; case EnemyStates.PATROL: isChase = false; agent.speed = speed * .5f; //判断一下指定的点 如果相同就给一个新的点，不同就往这儿移动 if (Vector3.Distance(wayPoint, transform.position) &lt;= agent.stoppingDistance) { isWalk = false; if (remainLookAtTime &gt; 0) remainLookAtTime -= Time.deltaTime; else GetNewWayPoint(); } else { isWalk = true; agent.destination = wayPoint; } break; case EnemyStates.CHASE: //追逐玩家 //在攻击范围内攻击 //配合动画 isWalk = false; isChase = true; agent.speed = speed; if (!FoundPlayer()) { //拉脱回上一个状态 isFollow = false; if (remainLookAtTime &gt; 0) { agent.destination = transform.position; remainLookAtTime -= Time.deltaTime; } else if (isGuard) { enemyStates = EnemyStates.GUARD; } else { enemyStates = EnemyStates.PATROL; } } else { isFollow = true; agent.isStopped = false; agent.destination = attackTarget.transform.position; } if (TargetInAttackRange() || TargetInSkillRange()) { isFollow = false; agent.isStopped = true; if (lastAttackTime &lt; 0) { lastAttackTime = characterStats.attackData.coolDown; //暴击判断 characterStats.isCritical = UnityEngine.Random.value &lt; characterStats.attackData.criticalChance; //执行攻击 Attack(); } } break; case EnemyStates.DEAD: break; } } void Attack() { transform.LookAt(attackTarget.transform); if (TargetInAttackRange()) { //近身攻击动画 anim.SetTrigger(&quot;Attack&quot;); } if (TargetInSkillRange()) { //技能攻击动画 anim.SetTrigger(&quot;Skill&quot;); } } bool FoundPlayer() { var colliders = Physics.OverlapSphere(transform.position, sightRadius); foreach (var target in colliders) { if (target.CompareTag(&quot;Player&quot;)) { attackTarget = target.gameObject; return true; } } attackTarget = null; return false; } bool TargetInAttackRange() { if (attackTarget != null) return Vector3.Distance(attackTarget.transform.position, transform.position) &lt;= characterStats.attackData.attackRange; else return false; } bool TargetInSkillRange() { if (attackTarget != null) return Vector3.Distance(attackTarget.transform.position, transform.position) &lt;= characterStats.attackData.skillRange; else return false; } // todo: 随机生成一个点 void GetNewWayPoint() { remainLookAtTime = lookAtTime; float randomX = UnityEngine.Random.Range(-patrolRange, patrolRange); float randomZ = UnityEngine.Random.Range(-patrolRange, patrolRange); // Vector3 randomPoint = new Vector3(transform.position.x + randomX, transform.position.y, // transform.position.z + randomZ); Vector3 randomPoint = new Vector3(guardPos.x + randomX, transform.position.y, guardPos.z + randomZ); //y还是保持它自身的刚体影响，因为地面上有坑坑洼洼 // todo: 可能出现的问题,不能这么简单就得到这个点 // wayPoint = randomPoint; NavMeshHit hit; wayPoint = NavMesh.SamplePosition(randomPoint, out hit, patrolRange, 1) ? hit.position : transform.position; //这个函数返回一个bool值，√使得怪物的最终点为这个，否则停留于原地 } private void OnDrawGizmosSelected() { Gizmos.color = Color.blue; Gizmos.DrawWireSphere(transform.position, sightRadius); }}","link":"/2022/10/15/b%E7%AB%99m_studio3drpg15-16/"},{"title":"麦扣 3DRPG游戏开发教程 17-18集","text":"🎮 17 敌人的接受伤害 如果动画系统里的动画打不上关键帧，那么就回到素材，ctrl+d，复制一份，调整更换掉（需要回到状态机黑色连线框对应的更改掉） 然后就可以打上关键帧🌶 18 敌人的死亡每次试玩数值都被更改，这是scriptObect特性 sqrt是开方， sqr是平方 拉脱战后 史莱姆应该回到原点 并且转头也应该在原点 在awake应该记录 123456789101112131415161718192021222324252627282930 private Quaternion guardRotation;//------------------------------------ private void Awake() { //自有组件、自有变量放在awake anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); speed = agent.speed; guardPos = transform.position; ⭐ guardRotation = transform.rotation; ⭐ remainLookAtTime = lookAtTime; characterStats = GetComponent&lt;CharacterStats&gt;(); }//----------------------------------- switch (enemyStates) { case EnemyStates.GUARD: isChase = false; if (transform.position != guardPos) { isWalk = true; agent.isStopped = false; agent.destination = guardPos; if (Vector3.SqrMagnitude(guardPos - transform.position) &lt;= agent.stoppingDistance) { isWalk = false; transform.rotation = ⭐Quaternion.Lerp(transform.rotation,guardRotation,.01f);⭐ } } break; 使其慢慢旋转的函数Quaternion.Lerp(transform.rotation,guardRotation,.01f); 这个函数会从当前的数值慢慢转换到 最初记录值 会经历0.01秒 动画系统里👉布尔通常是代表状态 trigger 通常表示 当时那一下触发的条件 启用某个组件1agent.enabled = false;","link":"/2022/10/15/b%E7%AB%99m_studio3drpg17-18/"},{"title":"麦扣 3DRPG游戏开发教程 19-21集","text":"🎮 19 GameManager 泛型单例泛型创建的方法 1public class Singleton&lt;T&gt; : MonoBehaviour where T : Singleton&lt;T&gt; 大概是不需要一个一个创建单例，可以.这样的调用，非常方便 生命周期函数之 onenable /ondisenable123456789private void OnEnable() { } private void OnDisable() { } 这两个方法是在gameObject被设置为active true和 false的时候调用的一般来说，我们添加委托或者事件的一对方法是放在onEnable和OnDisable当中的所以这样的委托或者事件应该不对gameObject本身的active进行处理 20 有一些BUG我倒着找寻了到底哪里错了 仍然没有找到，最后的解决办法是 在玩家死亡后的函数检测里 使用标签寻找到 史莱姆的动画组件 然后更改其条件 😓 12345678if (isDead) { GameManager.Instance.NotifyObservers(); slimeAnimator = GameObject.Find(&quot;Slime&quot;).GetComponent&lt;Animator&gt;(); slimeAnimator.SetBool(&quot;CheckDead&quot;,true); slimeAnimator.SetBool(&quot;Win&quot;,true); } 21 制作更多的敌人之前的问题都得到了解决 就是怪物应该一开始不能存在 在场景生成之时同期加载怪物 这个时候就可以完美执行了 怪物 scriptObject模板数据不共享 slime弄一个模板数据，两个都设置一下 (就是弄一个数据模板，当怪物生成时候复制一份，这样不会修改源文件) 披甲龙龟 首先在prefabs内找到龙龟，拖拽到hierarchy 添加了组件、数据和史莱姆一样，动画方面是直接复制史莱姆的一个动画animator，然后更改对应的动画文件 （另外的一个小技巧：创建一个animator override controller） 导入新的素材 然后放到地图我从商店里下载好素材，整理好文件夹，然后升级一下渲染管线（edit👉 render pipline 👉整个project）","link":"/2022/10/18/b%E7%AB%99m_studio3drpg19-21/"},{"title":"麦扣 3DRPG游戏开发教程 22-23集","text":"🎮 22 设置兽人士兵skill Range 设置技能范围 描述：当玩家试图穿过兽人 将击退玩家 复制出来的动画器与override区别在于 override一旦更改将修改之前引用的那个动画控制器（一起改变） FSM 有线状态机在动画机内那个选中一个动画，选择右上角的Add behavior（添加一个行为） 请留意这个script文件默认创建在asset根目录，我们需要规整一下 它的周期函数 （使用哪个将其取消注释，都是很有用的回调函数） 23 Extension Method 扩展方法静态类的数值应该用常量* 为什么要声明变量，其实如果是就这个地方用的话，声明不声明都一样。但是现实情况常常是一个变量会有很多地方会用到，到时候需要修改的时候一个一个改吗，所以习惯性的写上是最好的 在Unity3D中， Vector3.Dot 表示求两个向量的点积; Vector3.Cross 表示求两个向量的叉积。 1234567891011121314using UnityEngine;public static class ExtensionMethod{ private const float dotThreshold = .5f; public static bool IsFacingTarget(this Transform transform,Transform target) { var vectorToTarget = target.position - transform.position; vectorToTarget.Normalize(); float dot = Vector3.Dot(transform.forward, vectorToTarget); return dot &gt;= dotThreshold; //如果大于就在范围之内，因为分母变小，分母就是那个角度 }} (this Transform transform,Transform target) （out 扩展左边的，ref 传入右边的参数） 获取那个单位向量，和他本身的向量点乘 Vector.dot 是求cos值 角度越大，值越小，因为是分母 评价：绕桩打法","link":"/2022/10/21/b%E7%AB%99m_studio3drpg22-23/"},{"title":"麦扣 3DRPG游戏开发教程 24-26集","text":"🎮 24 石头人兽人有个bug：快走到目标点时会打滑，不让怪打滑，就是需要不勾选 Nav Mesh Agent 的 auto breaking 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class Golem : EnemyController{ [Header(&quot;Skill&quot;)] public float kickForce = 25; public void KickOff() { a if (attackTarget != null &amp;&amp; transform.IsFacingTarget(attackTarget.transform) ) { var targetStats = attackTarget.GetComponent&lt;CharacterStats&gt;(); Vector3 direction = (attackTarget.transform.position - transform.position).normalized; attackTarget.GetComponent&lt;NavMeshAgent&gt;().isStopped = true; attackTarget.GetComponent&lt;NavMeshAgent&gt;().velocity = direction * kickForce; targetStats.GetComponent&lt;Animator&gt;().SetTrigger(&quot;Dizzy&quot;); targetStats.TakeDamage(characterStats, targetStats); // attackTarget.GetComponent&lt;Animator&gt;().SetTrigger(&quot;Hit&quot;); //attackTarget.GetComponent&lt;Animator&gt;().SetTrigger(&quot;Hit&quot;); } }} 攻击不到石头人的原因： 石头人中心点大于1 25 没啥可写的 26 石头人扔石头 扔出来的石头可以击打玩家一段距离12345678910111213141516171819202122232425262728293031using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class Rock : MonoBehaviour{ public Rigidbody rb; [Header(&quot;Basic Settings&quot;)] public float force; public GameObject target; private Vector3 diretion; private void Start() { rb = GetComponent&lt;Rigidbody&gt;(); FlyToTarget(); } public void FlyToTarget() { if (target == null) { target = FindObjectOfType&lt;PlayerController&gt;().gameObject; } diretion = (target.transform.position - transform.position + Vector3.up).normalized; //这是一个角度； rb.AddForce(diretion * force, ForceMode.Impulse); }} 错误记录：扔出的石头无法造成伤害 原因：rock预制体没有给石头赋值伤害 😓 看物体的刚体速度 1Debug.Log(rb.velocity.sqrMagnitude); 结合粒子系统 有个bug，当我走出去那个范围，石头将不会生成","link":"/2022/10/22/b%E7%AB%99m_studio3drpg24-26/"},{"title":"麦扣 3DRPG游戏开发教程 8-11集","text":"🎮 08 动画控制器首先在动画系统内添加 blend tree 设置好动画 随后在代码内控制速度对应的动画播放 注：注释的代码是不相关的代码，是前面的 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour{ //private NavMeshAgent agent; private Animator anim; //首先获取 animator private void Awake() { //agent = GetComponent&lt;NavMeshAgent&gt;(); anim = GetComponent&lt;Animator&gt;(); } //private void Start() //{ //MouseManager.Instance.OnMouseClicked += MoveToTarget; //这是一个事件 //} private void Update() { SwitchAnimation(); } void SwitchAnimation() { anim.SetFloat(&quot;Speed&quot;, agent.velocity.sqrMagnitude); //将agent的速度传给动画 } //void MoveToTarget(Vector3 target) //{ //agent.destination = target; //}} 09 改进细节 （shader graph） 遮挡 取消树的射线 改变树的图层为 🐉忽略射线🐉 第二种方法：由于代码中的碰撞是collider，只需要取消物体的mesh collider 即可 10 设置敌人将史莱姆和蜗牛的材质都升级到urp材质 创建个脚本叫 enemy controller.cs 12[RequireComponent(typeof(NavMeshAgent))]//将脚本拖拽到物体上 会自动创建一个NavMeshAgent 敌人的遮挡剔除 设置一个图层为enemy 回到pipline settings找到render 在layer mask中 选中enemy（那个是可以多选的），同样infront内layer mask 也要选上 修改鼠标指针贴图 123456789101112131415161718192021222324//回到MouseManager.csvoid SetCursorTexture() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); //鼠标的位置与相机的催化剂 if (Physics.Raycast(ray, out hitInfo)) { //切换鼠标贴图 switch (hitInfo.collider.gameObject.tag) { case &quot;Ground&quot;: Cursor.SetCursor(target,new Vector2(16,16),CursorMode.Auto); //纹理，锚点，切换模式 break; ----------------------- case &quot;Enemy&quot;: Cursor.SetCursor(attack,new Vector2(16,16),CursorMode.Auto); //当鼠标指针掠过敌人，指针会变成🗡 break; ----------------------- } } } 😀 11 点击敌人玩家跑过去攻击动画协程 //订阅事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour{ private NavMeshAgent agent; private Animator anim; private GameObject attackTarget; private float lastAttackTime; //攻击冷却时间 private void Awake() { agent = GetComponent&lt;NavMeshAgent&gt;(); anim = GetComponent&lt;Animator&gt;(); } private void Start() { MouseManager.Instance.OnMouseClicked += MoveToTarget; //这是一个事件 MouseManager.Instance.OnEnemyClicked += EventAttack; } private void Update() { SwitchAnimation(); lastAttackTime -= Time.deltaTime; } void SwitchAnimation() { anim.SetFloat(&quot;Speed&quot;, agent.velocity.sqrMagnitude); //将agent的速度传给动画 } void MoveToTarget(Vector3 target) { //⭐核心⭐ agent.destination = target; agent.isStopped = false; } private void EventAttack(GameObject target) { if (target != null) { attackTarget = target; StartCoroutine(MoveToAttackTarget()); } }//延迟 IEnumerator MoveToAttackTarget() { agent.isStopped = false; //转向这个攻击目标 transform.LookAt(attackTarget.transform); //判断攻击距离 其实就是个检测条件 while (Vector3.Distance(attackTarget.transform.position, transform.position) &gt; 1) { agent.destination = attackTarget.transform.position; yield return null; } //一旦跑到接近点 agent.isStopped = true; //attack if (lastAttackTime&lt;0) { anim.SetTrigger(&quot;Attack&quot;); lastAttackTime = 0.5f; } }} //获取GameObject的坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using System;// using UnityEngine.Events;// [System.Serializable]// public class EventVector3 : UnityEvent&lt;Vector3&gt;public class MouseManager : MonoBehaviour{ // public EventVector3 OnmouseClicked; private RaycastHit hitInfo; public static MouseManager Instance; public event Action&lt;Vector3&gt; OnMouseClicked; public event Action&lt;GameObject&gt; OnEnemyClicked; public Texture2D point, doorway, attack, target, arrow; private void Awake() { if (Instance != null) { Destroy(gameObject); } Instance = this; } private void Update() { SetCursorTexture(); MouseControl(); } void SetCursorTexture() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); //鼠标的位置与相机的催化剂 if (Physics.Raycast(ray, out hitInfo)) { //切换鼠标贴图 switch (hitInfo.collider.gameObject.tag) { case &quot;Ground&quot;: Cursor.SetCursor(target,new Vector2(16,16),CursorMode.Auto); //纹理，锚点，切换模式 break; case &quot;Enemy&quot;: Cursor.SetCursor(attack,new Vector2(16,16),CursorMode.Auto); //当鼠标指针掠过敌人，指针会变成🗡 break; } } } void MouseControl() { if (Input.GetMouseButtonDown(0) &amp;&amp; hitInfo.collider != null) { if (hitInfo.collider.gameObject.CompareTag(&quot;Ground&quot;)) { OnMouseClicked?.Invoke((hitInfo.point)); } ------------------------ if (hitInfo.collider.gameObject.CompareTag(&quot;Enemy&quot;)) { OnEnemyClicked?.Invoke((hitInfo.collider.gameObject)); } ------------------------ } }} //打断攻击动画 在移动方法内添加终止协程 123456789void MoveToTarget(Vector3 target) { //打断攻击动画 StopAllCoroutines(); //⭐核心⭐ agent.destination = target; agent.isStopped = false; }","link":"/2022/10/09/b%E7%AB%99m_studio3drpg8-11/"},{"title":"C# 委托与事件","text":"🐉 Action委托的使用 在一个函数里面调用另一个函数，只不过这个函数是当作参数传递进来的 先设置一个 Action 类型的变量， 然后将函数存进变量， 然后运行这个变量，效果等同于运行这个函数，当然也可以传进去多个函数，然后在运行那个变量的时候，会一同执行 123456789101112131415161718192021222324252627282930313233class Program{ static Action function; //传递参数👇 static Action &lt;string,int,int&gt;function2; static void Main() { // function += Test1; // function += Test2; // function(); // 不需要时可以移除 // function -= Test2 //------------------------------- function2 += PassParameter; function2(&quot;result：&quot;,100,33); } static void Test1() { Console.WriteLine(&quot;Test1 had been writed 1&quot;); } static void Test2() { Console.WriteLine(&quot;Test2 had been writed 2&quot;); } static void PassParameter(string str,int a,int b) { Console.WriteLine(str+(a+b)); //如果不加括号 它会以为是字符类型，直接拼接了属于是 }} 请留意：Main主函数必须是静态的 Action不支持返回值，于是有了Func Func 实现带有返回值的委托调用 可以绑定带有返回值的方法 并且接受返回的结果 123456789101112131415161718192021class Program{ static Func&lt;int, int, int&gt; func1; //其中第一个参数永远是其返回值，第二个第三个才是函数的类型 static void Main() { func1 += Test1; int result = func1(100, 33); //委托调度的时候 其实就是调度方法 Console.WriteLine(result); func1 -= Test1; //同样也支持移除 } static int Test1(int a,int b) { return a + b; } } 请留意：如果+=多个值，只会返回最终的一个结果，以上全部覆盖了 Func最多支持16个参数的方法&lt; result , 1 , … , 16?15 &gt;，并且每个方法都有一个返回值 也可以当作参数传递👇 12345678910111213141516171819202122class Class{ static void Main() { TestAll(test); } static void TestAll(Func&lt;int,int,int&gt; callBack) { Console.WriteLine(&quot;OK&quot;); int result = callBack(100, 33); Console.WriteLine(result); } static int test(int a ,int b) { return a + b; }} 如果是想在外部赋值应该在函数testAll参数callBack后 再设置两个参数 古老的委托👉delegate 老师评价：自由 但初学者觉得语法怪 我の评价：这不都是一样的么 12345678910111213141516171819202122232425262728293031 class Class { delegate void Delegate(); private static Delegate delegate1; static void Main() { delegate1 += test1; delegate1 += test2; delegate1(); Console.WriteLine(&quot;-------------------------------------&quot;); delegate1 -= test1; delegate1(); } static void test1() { Console.WriteLine(&quot;this test 1&quot;); } static void test2() { Console.WriteLine(&quot;this test 2&quot;); } } delegate 当作参数传入的例子 就像先声明一个数组，把每个方法存到里面 然后自定义一个函数，形参是个数组，然后调用的时候赋值 这个时候就能把数组内所有的元素都跑一遍 1234567891011121314151617181920212223242526272829303132333435class Class{ delegate void Delegate(); static Delegate delegate1; static void Main() { delegate1 += test1; delegate1 += test2; // delegate1(); // Console.WriteLine(&quot;-------------------------------------&quot;); // delegate1 -= test1; // delegate1(); // 用一个方法传入另一个方法----------------------------- container(delegate1); } //-----------------------♥ static void container(Delegate d) { Console.WriteLine(&quot;tets~~~~~~~~~~~~~~&quot;); d(); } static void test1() { Console.WriteLine(&quot;this test 1&quot;); } static void test2() { Console.WriteLine(&quot;this test 2&quot;); }} 带有参数的 同样也只是计算最后一个函数 1234567891011121314151617181920212223242526272829class Class{ delegate int Delegate(int a , int b ); private static Delegate delegate1; static void Main() { delegate1 += test1; delegate1 += test2; //⭐ int result = delegate1(3,4) //⭐ Console.WriteLine(result); } static void container(Delegate d1) { Console.WriteLine(d1); } static int test1(int a , int b ) { return a + b; } static int test2(int a , int b ) { return a * b; }} 留意：若是想打印出所有的方法应该在以下⭐处改动 1234567891011121314151617181920212223242526272829303132333435class Class{ delegate int Delegate(int a , int b ); private static Delegate delegate1; static void Main() { delegate1 += test1; delegate1 += test2; // delegate1(); // Console.WriteLine(&quot;-------------------------------------&quot;); // delegate1 -= test1; // delegate1(); // 用一个方法传入另一个方法----------------------------- //⭐⭐⭐⭐ VARIABLE👇 foreach (Delegate VARIABLE in delegate1.GetInvocationList()) { Console.WriteLine(VARIABLE(4,3)); } } static void container(Delegate d1) { Console.WriteLine(d1); } static int test1(int a , int b ) { return a + b; } static int test2(int a , int b ) { return a * b; }} Event实际上是对delegate的封装 在一个脚本对另一个脚本委托的注册 请留意调用的时候 一定要重新写个新函数，如上的RunEvent() 委托和事件的核心作用 解耦各个模块 避免直接去调度其他模块的方法 而是通过注册、移除注册的方式，来控制其他模块方法的调度","link":"/2022/12/14/cSharp%20%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/"},{"title":"C# API for Unity","text":"🎮 Unity事件Input 一种是命名好的，一种是对应的码 检测空格按着 Input.GetKey(“space”); 检测空格按下 Input.GetKeyDown(“space”); 键名大全 十字移动： up down left right KeyCode.A …… KeyCode.Z 鼠标事件 鼠标按下👈🗡 GetMouseButtonDown（0） 鼠标按着👈🗡 GetMouseButton（0） 鼠标抬起👈🗡 GetMouseButtonUp（0） 请留意： 0代表👈🗡1👉🗡2🀄🗡 检测两个物体碰撞 OnCollisionEnter是Mono内置函数 123456789void OnCollisionEnter(Collision collision){ if (collision.transform.name == &quot;Floor&quot;) { //当两个刚体碰撞时，如果被碰撞的刚体的名字为Floor Debug.Log(&quot;hit the floor&quot;); }}//无法连跳的逻辑，首先设置一个bool = false， 然后当两个刚体碰撞时 设置成true，其实初始即是true，代表可以跳跃，当我按了空格，立即设置为false，即不可连跳，当由于重力的作用下跌使得二者刚体碰撞，现在又可以跳跃 旋转 transform.RotateAround(参数一：某个点（相当于公转），参数二：这个物体的某个轴（相当于自传），参数三：角度（旋转的速度）); 机位 只能有一个摄像机生效，但您可以根据需要来使用代码来更改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.Collections;using System.Collections.Generic;using UnityEngine;public class GameController : MonoBehaviour{ public GameObject[] gameCameras; int gameCamerasCount = 0; private void Start() { print(gameCameras.Length); focusOnCamera(gameCamerasCount); } private void Update() { if (Input.GetMouseButtonDown(0)) { changeCamera(1); } } void focusOnCamera(int index) {//工人 for (int i = 0; i &lt; gameCameras.Length; i++) { gameCameras[i].SetActive(i == index); } //🥝🥝🥝开启 关闭相机 } void changeCamera(int direction) {//领导 gameCamerasCount += direction; if (gameCamerasCount &gt;= gameCameras.Length) { gameCamerasCount = 0; } if (gameCamerasCount &lt; 0) { gameCamerasCount = gameCameras.Length - 1; } focusOnCamera(gameCamerasCount); //🥝🥝🥝循环往复切换相机的索引 }}//以这种方式 来启用某个相机 关闭某些相机 相机追逐 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;public class ChaseCamera : MonoBehaviour{ public Transform target; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { transform.LookAt(target); }} 在一个脚本内，访问/修改其他脚本文件中的属性 12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;public class player : MonoBehaviour{ public GameObject bulletPrefab; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (Input.GetMouseButtonDown(0)) { GameObject bulletObject = Instantiate(bulletPrefab); bullet bullet = bulletObject.GetComponent&lt;bullet&gt;(); Vector3 shootingDirection = new Vector3( .3f, .2f, 1 ); bullet.shootingDirection = shootingDirection.normalized; //normalized向量归一，只是代表一个方向 } { } }} 物体生命周期 以时间为判断 1234567891011121314151617181920212223242526using System.Collections;using System.Collections.Generic;using UnityEngine;public class bullet : MonoBehaviour{ public float shootingForce = 10f; public Vector3 shootingDirection; public float lifeTime = 3f; void Start() { GetComponent&lt;Rigidbody&gt;().AddForce(shootingDirection * shootingForce); } // Update is called once per frame void Update() { lifeTime -= Time.deltaTime; //是每个独立の个体 if(lifeTime &lt;= 0) { Destroy(gameObject); } }}","link":"/2022/09/07/cSharpAPIForUnity/"},{"title":"麦扣 3DRPG游戏开发教程 27-30集","text":"🎮 27 UI开发设置思路是一个canvas挂在两个image 然后把图层最上方的模式改为filled 并设置模式为horizontal LateUpdate() 在渲染一帧之后才会一直执行 28 玩家升级没啥好记的 29 玩家信息显示没啥好记录的 canvas设置之类的，下载了一款字体叫high jink，还有UI需要根据设备尺寸来达到良好の显示 获得子物体＆孙物体 1expSlider = transform.GetChild(1).GetChild(0).GetComponent&lt;Image&gt;(); 30 shader graph 制作传送门 取消物体的影子找到物体的meshRender 取消cast Shadows 设置为off shader graph中的power节点 通常是增强效果","link":"/2022/10/22/b%E7%AB%99m_studio3drpg27-30/"},{"title":"npm 与 Node 版本差异引起的警告","text":"🚀 配置 一般装了新的系统，先去node官网下载node稳定版👉安装成功后，在cmd命令中使用node -v 和 npm -v来检测是否安装成功，一般来说，node是成功的，npm会有一个警告，这个时候就需要配置一下，否则使用会出问题 🐉当然解决办法是很多，我记录了我个人比较喜欢的一种 首先，要确保可以通过从 PowerShell 执行 npm 脚本。以管理员身份打开 PowerShell，运行以下命令： 1Set-ExecutionPolicy Unrestricted -Scope CurrentUser -Force 1npm install --global --production npm-windows-upgrade 1npm-windows-upgrade --npm-version latest 1Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Force 使用npm -v 检测一下，就正常了，总结原因是npm和node的版本不一致","link":"/2022/08/01/npm%20%E4%B8%8E%20Node%20%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E5%BC%95%E8%B5%B7%E7%9A%84%E8%AD%A6%E5%91%8A/"},{"title":"一个交互效果","text":"🌩 在技术栈上我用的原生 √vavScript👇 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * { padding: 0; margin: 0; overflow: hidden; } #box { width: 200px; height: 500px; position: relative; } #box1 { position: absolute; top: 0; width: 200px; height: 200px; background-color: aqua; } #box2 { position: absolute; top: 0; z-index: -1; width: 200px; height: 200px; background-color: pink; } #button { width: 100px; height: 50px; background-color: red; }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;(●'◡'●)😄&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;button&quot; onclick=&quot;trigger()&quot;&gt; &lt;h1 id=&quot;button1&quot;&gt;点我&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let controller = true; let speed = 20; function trigger() { let position = 0 let ele = document.getElementById(&quot;box2&quot;); if (controller) { let moving = setInterval(across, 10); document.getElementById(&quot;button1&quot;).innerHTML = &quot;放回去&quot; function across() { if (speed &lt; 200) { speed += 5 ele.style.transform = `translateY(${speed}px)` } if (speed == 200) { clearInterval(moving); } } controller = !controller console.log(controller) return } if (!controller) { let moving = setInterval(acrossBack, 10); document.getElementById(&quot;button1&quot;).innerHTML = &quot;拿出来&quot; function acrossBack() { if (speed &gt; 0) { console.log(speed); speed -= 5 ele.style.transform = `translateY(${speed}px)` } if (speed == 0) { clearInterval(moving); } } controller = !controller console.log(controller); return } }&lt;/script&gt;&lt;/html&gt;","link":"/2022/09/03/%E4%B8%80%E4%B8%AA%E4%BA%A4%E4%BA%92%E6%95%88%E6%9E%9C/"},{"title":"一年制水硕国家","text":"🏫 各国一年制硕士介绍 1.白俄罗斯(专制政权) 申请要求： a.学历要求：具有前置学历毕业证书及学位证书。 b.语言要求：英语等级PETS4考试成绩425分以上或取得对外俄语等级考试B1级优先录取。 2.英国 申请要求： a.学历要求：GPA在70分以上，若想申请热门专业及院校，GPA需在80分以上; b.语言要求：雅思要求6.5分以上，或者托福92分以上。另外大专毕业则还要求至少有2年工作经验。 留学费用：a.学费：12w-20w人民币左右;b.生活费：7.5w-9w人民币左右。 3、马来西亚 申请要求： a.学历要求：GPA在70分以上，若想申请热门专业及院校，GPA需在80分以上; b.语言要求：雅思要求5.5分以上 4.中国香港 申请要求： a.学历要求：GPA在80-85分左右，而且最好本科是相关专业; b.语言要求：雅思至少在6.0分-6.5分以上。 另外要注意，申请香港硕士要提前规划，趁早占坑，因为香港是早申请早录取的原则。 留学费用：a.学费：13w-18w人民币左右;b.生活费：5w-8w人民币左右。 5.澳大利亚 申请要求： a.学历要求：GPA在75分以上，且要求申请者本科是相关专业或有相关工作经验; b.语言要求：雅思6.5分以上，且单项不得少于6分。另外申请者若是没有语言成绩可以先读语言班。 留学费用：a.学费：16w-25w人民币左右;b.生活费：7w-9w人民币左右。 6、西班牙 申请要求： a.学历要求：专科或专科以上学历 b.语言要求：A2水平 7.新西兰 申请要求： a.学历要求：GPA在70分-85分左右; b.语言要求：雅思要求6.5分左右。 留学费用：a.学费：11w-19w人民币左右;生活费：8W人民币左右。 8.美国 申请要求： a.学历要求：名校要求申请者GPA在80分以上; b.语言要求：雅思要求6.5分以上或托福100分以上，没有语言成绩可以读预科。 留学费用：a.学费：22w-44.86W人民币左右;生活费4.2w-5.6W人民币左右。 9.新加坡 申请要求： a.学历要求：申请者最好是985和211毕业的学生，GPA在80分以上; b.语言要求：雅思要求6分以上。 留学费用：a.学费：12w-20w人民币左右;b.生活费：3w-6w人民币 10.加拿大 申请要求： a.学历要求：GPA在80分以上，要求申请者本科是相关专业; b.语言要求：雅思要求6.5分以上或托福80分以上，GMAT成绩650分以上。 留学费用：a.学费：10W-15W人民币左右;b.生活费：7-10w人民币左右。 11.法国 申请要求： a.学历要求：本科毕业，且有相关专业背景及工作经验; b.语言要求：雅思要求6分以上，或法语B2以上。 留学费用：a.学费：10W-18w人民币;b.生活费：5w-8w人民币。 12.荷兰 申请要求： a.学历要求：GPA在75分以上，且要求申请者背景是985、211院校; 语言要求：雅思要求6.5分左右。 留学费用：a.学费：10W-15w人民币左右;b.生活费：3.6W-4.8W人民币左右。 13.德国 申请要求： a.学历要求：GPA尽量在80分以上，且优先录取985、211大学的学生; .语言要求：雅思要求6分以上或者托福550分以上。 留学费用：a.学费：公立学校免费;b.生活费：5W人民币左右。 一年制硕士优劣势分析 1.优势 (1)教学质量高：国外的教学质量十分先进，且同等背景的学生可以得到更好的教育。简单来说，申请者申请国外和国内旗鼓相当的大学，结果是国外比较容易申请。 (2)降低时间成本：一年制硕士大大节约了留学生的时间成本，让其可以更早的积累工作经验。 (3)提高语言能力：在国外学习一年，难免是要用英语交流的。这样一来，语言能力就能得到提高。这对于学生回国以后就业也相当加分。 (4)文凭含金量高：海外留学的文凭这几年认可度很高，而且海龟也备受名企青睐。 2.劣势 (1)留学费用高：国外留学的费用比较高，随随便便就是几十万，对于普通家庭来说压力还是比较大的。 (2)时间紧，任务重：学生一年内就得完成所有的学业，课程难免就会安排的紧凑。这样一来，学生的压力也增加。 一年制硕士文凭认可度 就现在而言，一年制硕士文凭是受中国教育部认可的。而且我国现在十分支持学生出国开拓视野，并积极培养复合型人才。 我国还明文规定了，正规企业需给留学生提供文凭补助。简而言之，在同一家企业，一个职员是海外学历文凭的话，那他就比普通职员的文凭补助要多很多。 明确不接受非全日制本科的国家：德国、比利时。 接受的国家：英国、爱尔兰、瑞典、丹麦、法国、澳大利亚、新西兰、加拿大、美国、日本10国（以上国家有申请成功的案例支撑）。 荷兰、西班牙、意大利，据说也接受。 注意：接受的国家，并不是说该国所有大学都接受，只是部分大学接受。接受的意思是有资格申请，但是不一定会录取，因为录取还要看课程匹配度、绩点等。","link":"/2022/11/25/%E4%B8%80%E5%B9%B4%E5%88%B6%E6%B0%B4%E7%A1%95%E5%9B%BD%E5%AE%B6/"},{"title":"专注VR多人联机的教程 Photon常用的回调函数","text":"🎮 常用的回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 ⭐随机加入房间失败时候 public override void OnJoinRandomFailed(short returnCode, string message) { CreateAndJoinRoom(); } ⭐当创建好一个房间时会触发此 public override void OnCreatedRoom() { } ⭐第一位玩家加入时会触发此 public override void OnJoinedRoom() { Debug.Log(&quot;the 本地玩家是&quot;+PhotonNetwork.NickName+&quot;joined to&quot;+PhotonNetwork.CurrentRoom.Name+&quot;Player count&quot;+PhotonNetwork.CurrentRoom.PlayerCount); } ⭐其他玩家加入我的房间会触发此 public override void OnPlayerEnteredRoom(Player newPlayer) { } ⭐创建、有新玩家加入、更改了房间的财产 都会触发public override void OnRoomListUpdate(List&lt;RoomInfo&gt; roomList) { } ⭐当本地人离开房间时触发 public override void OnLeftRoom() { } ⭐当本地人断开连接时 public override void OnDisconnected(DisconnectCause cause) { } ⭐当本地人连接到Master public override void OnConnectedToMaster() { } 官网手册参考👇Photon Unity Networking 2: ILobbyCallbacks Interface Reference","link":"/2022/11/15/%E4%B8%93%E6%B3%A8VR%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E7%9A%84%E6%95%99%E7%A8%8B%20Photon%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"},{"title":"专注VR多人联机的教程 第5章","text":"🎮 5-1 synchronization变换同步 动画同步 刚体同步 甚至同步一些自定义数据 用到的组件是预制体上的photon view组件 将 observable 改成manual 然后将自己的transform拖进observed components内 (同时会自动添加一个photon transform view组件 这个是网络同步的核心) 运行演示效果 在unity里修改坐标 头显里可以看到运动 但用手柄控制头显里的，在unity端看不到运动 👇 5-2 photon官方提供的脚本MultiplayerVRSynchronization.cs 🚪下载地址https://www.aliyundrive.com/s/DP1p7TLz5Su 移除photon transform view 挂载 MultiplayerVRSynchronization.cs 将MultiplayerVRSynchronization组件拖拽进 photon view 的observed components内 以及其他的公共变量 5-3 网络抓取抓取一个物体能被大家看到 主要用的是 交互脚本上的event 告诉其他玩家该物体被抓到 写好触发事件之后 给触发物体添加一个photon view 同样设置👇，并把transform拖进 但是演示出现了一些震动 5-4 解决震动首先应当转移对象所有权 配置photon view ownership transfer 改成 request 然后在NetworkedGrabbing.cs脚本中 创建一个私有方法，用以创建转移权 👇完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System;using System.Collections;using System.Collections.Generic;using Photon.Pun;using Photon.Realtime;using UnityEngine;public class NetworkedGrabbing : MonoBehaviourPunCallbacks,IPunOwnershipCallbacks{ private PhotonView m_photonView; private void Awake() { m_photonView = GetComponent&lt;PhotonView&gt;(); } // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } private void TransferOwnership() { m_photonView.RequestOwnership(); } public void OnSelectEntered() { Debug.Log(&quot;Grabbed&quot;); TransferOwnership(); //被选中时 } public void OnSelectedExited() { //放下 } public void OnOwnershipRequest(PhotonView targetView, Player requestingPlayer) { Debug.Log(&quot;Ownership Requested for:&quot;+ targetView.name+&quot;from&quot;+requestingPlayer.NickName); m_photonView.TransferOwnership(requestingPlayer); } public void OnOwnershipTransfered(PhotonView targetView, Player previousOwner) { Debug.Log(&quot;Ownership Tranferred to:&quot;+ targetView.name+&quot;from&quot;+previousOwner.NickName); } public void OnOwnershipTransferFailed(PhotonView targetView, Player senderOfFailedRequest) { }} 5-5 继续改进 (RPC)在NetworkedGrabbing.cs 创建一个公共方法 完整代码👇 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798using System;using System.Collections;using System.Collections.Generic;using Photon.Pun;using Photon.Realtime;using UnityEngine;public class NetworkedGrabbing : MonoBehaviourPunCallbacks, IPunOwnershipCallbacks{ private PhotonView m_photonView; private Rigidbody rb; private bool isBeingHeld; //可以跟踪是否举起来 private void Awake() { m_photonView = GetComponent&lt;PhotonView&gt;(); } // Start is called before the first frame update void Start() { rb = GetComponent&lt;Rigidbody&gt;(); } // Update is called once per frame void Update() { if (isBeingHeld) { rb.isKinematic = true; gameObject.layer = 11; } else { rb.isKinematic = false; gameObject.layer = 9; } } private void TransferOwnership() { m_photonView.RequestOwnership(); } public void OnSelectEntered() { Debug.Log(&quot;Grabbed&quot;); m_photonView.RPC(&quot;StartNetworkGrabbing&quot;, RpcTarget.AllBuffered); if (m_photonView.Owner == PhotonNetwork.LocalPlayer) { Debug.Log(&quot;意味真的拿住了&quot;); } else { TransferOwnership(); } //被选中时 } public void OnSelectedExited() { //放下 Debug.Log(&quot;Released&quot;); m_photonView.RPC(&quot;StopNetworkGrabbing&quot;, RpcTarget.AllBuffered); } public void OnOwnershipRequest(PhotonView targetView, Player requestingPlayer) { if (targetView != m_photonView) { return; } Debug.Log(&quot;Ownership Requested for:&quot; + targetView.name + &quot;from&quot; + requestingPlayer.NickName); m_photonView.TransferOwnership(requestingPlayer); } public void OnOwnershipTransfered(PhotonView targetView, Player previousOwner) { Debug.Log(&quot;Ownership Tranferred to:&quot; + targetView.name + &quot;from&quot; + previousOwner.NickName); } public void OnOwnershipTransferFailed(PhotonView targetView, Player senderOfFailedRequest) { } [PunRPC] public void StartNetworkGrabbing() { isBeingHeld = true; } [PunRPC] public void StopNetworkGrabbing() { isBeingHeld = false; }}","link":"/2022/11/18/%E4%B8%93%E6%B3%A8VR%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E7%9A%84%E6%95%99%E7%A8%8B%20%E7%AC%AC5%E7%AB%A0/"},{"title":"专注VR多人联机的教程1-4章","text":"🎮 前期准备 建立普通的3d项目 导入SDK 在导出处修改纹理模式 在player里修改色彩模式 选择线性 install location 选择 automatic 多线程运行 quality XR Rig的 tracking origin mode 改为Floor 在资产添加这两个 随后在项目设置里 过滤一些词语 删除之前xr rig 重新添加 主相机视野穿模解决办法 设置头和body一个图层，然后在相机的渲染模式之下取消勾选该图层 优化传送区域 手动去设置有一个碰撞盒子，并指定单独的图层（在控制器和地面都需要修改 Interaction Layer Mask） XR Direct Interactor 这个组件允许手柄进行交互 最后别忘记 在主相机 和 镜子相机 内启用刚刚设置好的图层 被抓取物 以固定方向被抓取首先找个坐标，扔进grab组件的这里即可 所有的键位管理器 解决两个碰撞盒的冲突 在项目设置里的物理系统 多人联机平台 PHOTO资源商店 搜索pun 2 传送🚪PUN 2 - FREE | 网络 | Unity Asset Store 导入进去后 会要求输入appID 先去 PHOTO官网申请个账号 传送🚪https://www.photonengine.com/zh-CN/Photon 随后创建一个类型为Pun的应用，将出现的appid填入unity里即可 （可以更改一些设置,具体参考官网相关信息） 留意游戏的版本withPHOTO 他将用来区分新老玩家 如何连接服务器123456789101112131415161718192021222324252627282930313233343536373839using System.Collections;using System.Collections.Generic;using UnityEngine;using Photon.Pun;public class LoginManager : MonoBehaviourPunCallbacks{ #region Unity Methods // Start is called before the first frame update void Start() { Debug.Log(&quot;OK不&quot;); PhotonNetwork.ConnectUsingSettings(); //这句话表明链接到服务器 } // Update is called once per frame void Update() { } #endregion #region Photon Callback Methods public override void OnConnected() { Debug.Log(&quot;连接成功&quot;); } public override void OnConnectedToMaster() { Debug.Log(&quot;连接到Master&quot;); } #endregion} 使用开源的虚拟键盘 🚪GitHub - campfireunion/VRKeys: A drum-style keyboard for VR in Unity 同样也在资源商店里可以找到 👉vrkeys 不建议下载最新版本而是使用教程提供的网盘下载 🚪OneDrive 键盘生成位置是固定的 并且我个人感觉调节位置在VR眼镜里挺不好调节的 4-7连接服务器需要使用全局魔法，否则将不会测试成功 4-8 具有自定义属性的房间新UIprefab在附赠的下载链接内，不要恐慌 根据键值对决定进入房间的类型 const常量允许被其他脚本直接访问 4-12 实例化玩家使用PhotonNetwork.Instantiate()来生成一个prefab 请留意一定要给prefab添加一个 photon view 的组件 而且他将自带头显，你必须要删除原本的摄像机 4-13 继续改进可被别人看到需要给prefab挂载一个脚本 这个脚本用以生成prefab，但是剥夺了他们xr rig 4-14 修改一些潜在错误掉到地底下 12345678TeleportationArea[] teleportationAreas = GameObject.FindObjectsOfType&lt;TeleportationArea&gt;(); if (teleportationAreas.Length != 0) { foreach (var item in teleportationAreas) { item.teleportationProvider = localXRRigGameobject.GetComponent&lt;TeleportationProvider&gt;(); } } *遍历含有TeleportationArea脚本的游戏物体，如果存在（！=O），那么将该物体的TeleportationArea脚本下的公共变量将被赋予为👉某物体的组件下的provider就给他了 但是有个问题是所有的area都被赋予同样的provider* 好用的单例模式 123456789101112public static VirtualWorldManager Instance; private void Awake() { if (Instance != null &amp;&amp; Instance != this) { Destroy(this.gameObject); return; } Instance = this; } 这是另一个脚本可以直接访问","link":"/2022/11/15/%E4%B8%93%E6%B3%A8VR%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E7%9A%84%E6%95%99%E7%A8%8B1-4%E7%AB%A0/"},{"title":"专注VR多人联机的教程6-7章","text":"🎮 6-1本节自认为没什么东西好记的 6-2如何选择新角色后 到新场景里可以展现实现逻辑如下 👇 记录索引 读取索引 修改模型 7-1 🐉语音模块🐉商店搜索 photon voice 2 最基本的多人联网模块 应当创建一个PUN类型的应用 并将appid填入unity 语音则是需要创建一个voice类型的应用 7-2 实施语音需要两个组件：录音机和扬声器 通过唯一的photon view id链接 添加一个manager空物体， 挂载voice client 取消勾选 destory on load ⭐挂载record 并将此拖进voice client的primary record 勾选record下的voice detection 和 enable transmit 保存 随后在Resources文件夹下的玩家prefab 添加 photon voice view 然后在hierarchy的main avatar下创建一个名叫speaker的空物体对象 给它添加speaker组件 将随之产生的audio source设置成3d模式 完整的项目👇 https://1drv.ms/u/s!At2Y2Np4SXyvh7ZJdeeFPNAgJXdvdQ?e=qRX4W2","link":"/2022/11/21/%E4%B8%93%E6%B3%A8VR%E5%A4%9A%E4%BA%BA%E8%81%94%E6%9C%BA%E7%9A%84%E6%95%99%E7%A8%8B6-7%E7%AB%A0/"},{"title":"也只不过是赌徒罢了","text":"海边 想买一张往东的🚝票，一直往东，直到尽头·· 或许那大概是海边了，印象中的海边是沙滩和海风，但我不想去沙滩那样的海边，我想去看满是礁石的海边，不知道青岛有没有这样，大概就是我截的这张图这样的👆。如果你知道哪个地方有这样的，我俩可以坐公交或者地铁去那个地方。 你千万不要感到不好意思，你愿意出来见我，我俩一起去海边走走，聊聊天，我就很高兴啦，也都会百分百的尊重你。我会穿的干干净净的，在海边拍一些风景照，前几天我新买了个手机，我想试试搭配谷歌相机拍照是怎样的一种效果，当然，我也可以当你的专属摄影师，有一段时间我也研究过照片的构图，我想我的拍照水平应该还算可以。 是讲究人 如果饿了，你就带我去吃海鲜或者羊肉汤煎包都可以，并不需要去特别贵的地方，我请客或者我俩AA都可以🦄，整个过程应该是很轻松的，如果我给你留下一个坏印象我会很难过，我也会站在你的立场考虑，该说什么话不该说什么话我都明白，作为男孩这样是应该的。况且我又时常自诩是一个体面人儿。 关于自己以后的打算 我特想在青岛找一份和计算机相关的工作，干半年左右我就回家，届时我家里新房子也装修好了，没人打扰，适合备考考研，自己挣的钱应该也够生活了，因为我没有别的开销，至少不吸烟不喝酒，我算是把提升学历当做自己终身浪漫的事情了，如果考不上我就会一直考，只是每年会拿出几个月时间出来挣钱。 多年后我再次看到当初自己写下的东西，不禁说道“考个🔨的研究生，跟尼玛舔🐕一样，乐观人在学习编程语言，悲观人在学习外国语言。”","link":"/2022/05/20/%E4%B9%9F%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E8%B5%8C%E5%BE%92%E7%BD%A2%E4%BA%86/"},{"title":"俺喜欢の十种颜色","text":"🥝","link":"/2022/08/04/%E4%BF%BA%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8D%81%E7%A7%8D%E9%A2%9C%E8%89%B2/"},{"title":"关于 XR Rig 的所有","text":"🎮 输入系统使用基于action的头显👉 Floor 添加locomotion组件 给玩家添加provider（并把locomotion添加到provider的system里面） 新建一个空物体起名叫Input Action Manager 并为它添加Input Action Manager 这个脚本 ，在menu输入1，并选取默认的配置文件 default那个 移动先给地面添加area 然后添加碰撞盒 👉然后添加传送标记⚪（并设置图层，可以提升一下传送区域的Y值：高度，可以解决有时传送失败的问题） 连续移动给XR Rig（基于action）添加一个locomotion 并将XR Rig组件拖拽进 locomotion的XR Rig框框内 👆图是新的输入系统，我记得在项目设置里需要设置兼容两种输入 有个both英文 返回到XR Rig 👉 添加一个组件（continues move provider） 然后把刚刚创建的locomotion拖拽进continues move provider的system中 把XR Rig的主相机拖拽进continues move provider的forward source中 Use Reference决定哪个🎮生效 Move Speed决定了移动速度 转身给XR Rig添加个continuous turn provider（action-based） 并把locomotion推拽进continuous turn provider（action-based）的system公共变量内 Use Reference决定哪个🎮生效 turn speed决定的时候转的速度 传送给 XR Rig 加一个 teleportation provider 脚本 locomotion拖拽进 system里 teleport parent 然后对于基本控制器在添加 XR direct interactor 和 sphere collider👈这个允许🎮跟物体交互 选中RightHand Teleport Controller 将他的射线类型改成曲线 这个是上摇杆传送的核心然后需要修改一个键位 （很重要！！！） 搜索teleport sele ，因为教程里是右手所以选择 带right teleport 的， 还提供了一个通用开源项目，这对XR项目非常的实用 用来切换 传送控制器 和 基础控制器 我上传到我的阿里网盘了👇 https://www.aliyundrive.com/s/2o9AvvvkWRj 应当把这个脚本附加到折叠框（right hand parent）上 有许多变量需要赋值👇 传送区是地板 确保有个碰撞盒 为它添加一个area脚本，并指定碰撞盒子 这个element0就是自己的碰撞盒 一般来说还要地板的图层 添加图层起名叫Teleport 在area脚本和右上角Tag右边的Layer 都选择Teleport 最后最后 回到传送控制器，选择没被勾选的那个射线组件 将它的交互图层也选Teleport（先noting取消所有，然后再选择Teleport，到这一步射线只会与传送区交互，确保XR Rig的主相机culling mask勾选Teleport，否则将不会在画面里显示） 准心 是一个prefab，拖拽到area的 custom reticle 挂载的模型随头显运动这里用到了一个通用开源项目，应当挂载到 XR Rig 上 https://www.aliyundrive.com/s/Un2RTzJyEdX 它有许多需要变量赋值如图 红框内的头应该在的某个地方的高度 用以正常表达这些零散模型 默认左右手控制器设定 随后要去 project settings 里的 preset manager 栏下的（它应该有两个预设） 还需要过滤词👇 最后一步 添加个空物体 改名为 input action manager 并挂载 input action manager 这个默认组件 并添加默认的输入方案 此后在添加的 XR Rig（action） 会拥有默认的输入系统了 👇🎮键位设置比较符合直觉","link":"/2022/11/18/%E5%85%B3%E4%BA%8E%20XR%20Rig%20%E7%9A%84%E6%89%80%E6%9C%89/"},{"title":"🔥刘国柱Pico核心开发🔥","text":"🎮 PicoNeo3手柄按键 ⭐摇杆是二维向量⭐(CommonUsages.primary2DAxis) ⭐侧键、扳机键、菜单键、主副按键 都是bool类型⭐ (CommonUsages.gripButton) (CommonUsages.triggerButton) (CommonUsages.menuButton) (CommonUsages.primaryButton) (CommonUsages.secondaryButton) 改按键头显下的左右手 的XR Controller组件 中的select action属性 双击 reference 在弹出窗口同时修改select ＆ select Value 修改射线颜色颜色渐变的顺序是 从左到右👉🎮从近到远（组件在头显下的左右手柄内）vaild 代表有效 invaild 代表无效射线 ⭐基础传送是最基本的移动方式，但是类似于瞬移 地面 添加 teleportation area 组件 给头显添加 teleportation provider 和 Locomotion system 把Hierarchy内の头显拖进头显inspector下的locomotion的XR Origin 内 然后把Hierarchy内の头显 拖进 头显inspector下的teleportation provider的system里 再回到地面 把 头显 拖进teleportation area 组件的 teleportation provider 变量里 ⭐锚点传送给另一个地面添加一个teleportation anchor组件其中它的teleportation provider赋值为头显(XR Origin)锚点的位置由teleportation transform 一般把一个游戏物体扔进去就得到了那个三维位置 ⭐按键移动12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.XR;public class Controller : MonoBehaviour{ void Update() { Vector2 vec2DAxis = Vector2.zero; //0,0,0 InputDevices.GetDeviceAtXRNode(XRNode.LeftHand). TryGetFeatureValue(CommonUsages.primary2DAxis, out vec2DAxis); //InputDevices开头👉获取左手摇杆按钮的偏移量值，并赋值给vec2DAxis transform.position = new Vector3(transform.position.x + vec2DAxis * Time.deltaTime, transform.position.y, transform.position.z + vec2DAxis * Time.deltaTime); //z其实对应了纵轴的移动 }} UI创建一个canvas，请留意这个UI canvas是XR内的会生成一个event system，通常是可以作为canvas的子节点，然后给canvas创建一个普通的panel修改panel的尺寸，颜色，可以加一些文字、按钮（拖动条是slider）文字的锐利程度取决于canvas scaler的Dynamic pixel per unit 和 reference pixels per unity 前者是作用于文字，后者作用于精灵，前者越大越清晰，后者越小越清晰，精灵就是图片啊 等等 射线回调回调函数 在某些情况下 自动被调用的函数 就叫回调函数 点击事件 触发事件是需要把组件放到 被交互的物体上，假如我想坐在椅子上，我应该给椅子添加此组件grab是添加一个抓取效果，但有时我们只是想触发一些自己的事件，这个时候就需要simple组件，它只是简单的做回调 simple支持的动作 更换材料 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.XR.Interaction.Toolkit;public class SimpleInteractorController : MonoBehaviour{ public GameObject ball; public Material blue, yellow, grey; public void onSelected(XRBaseInteractor interactor) { } public void onDeSelected(XRBaseInteractor interactor) { } public void onHoverEnter(XRBaseInteractor interactor) { ball.GetComponent&lt;MeshRenderer&gt;().material = blue; } public void onHoverExit(XRBaseInteractor interactor) { } public void onActivated(XRBaseInteractor interactor) { } public void onDeActivated(XRBaseInteractor interactor) { }}//其实很好理解，获取一个物体的组件の网格渲染器の材料 ，并将它设置为blue 注⭐：写完代码，挂载上脚本，然后在simple组件内选择刚刚写好的触发的对应方法 它才会生效","link":"/2022/09/18/%E5%88%98%E5%9B%BD%E6%9F%B1Pico%E6%A0%B8%E5%BF%83%E5%BC%80%E5%8F%91/"},{"title":"刘国柱Pico环境配置","text":"🎮 添加一个可以感应玩家头盔＆手柄的控件我们选择 在hierarchy 内右键追加 XR Origin然后给XR orgin追加一个组件 名为PXR_Manager👈👉手🎮、然后给他应用上默认设置 给左右手添加上模型请留意 控制器🎮预留了一个public prefab，而不是成为他们的子组件 再做一些设置才能使🎮生效 给XR Origin 添加一个 input action manager介绍说需要appid版权什么的才能打包到pico内，从官网获取 设备id、appid 等等、或者使用adb查看设备（比如只能在某些机子上运行、你需要提供这些）启用开发者模式","link":"/2022/09/18/%E5%88%98%E5%9B%BD%E6%9F%B1Pico%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"剑魔笔记","text":"🗡 常见的模型格式如下不过通常都是到手后转成glb格式(Unity只认fbx/obj) Blender 快捷键中键 ：旋转画面 按住 Shift + 中键 ：平移 按住 Ctrl + 中键 ：左右拖动缩放画面 按住 Alt + 中键 ：自动吸附角度 小键盘4和6分别是 左右旋转 2和8分别是 上下旋转 1379分别是看它的前侧上下 5透视角度的切换 B 方块的圈选 点B的时候的按住shift 可以做圈选添加 先画一个框再按shift 可以把未勾选的取消圈选 G 移动物体 想吸附到某个轴 按了G再按X或Y或Z 或者按中键也可以自动抉择吸附到某个轴 旋转R 工具栏第四个 按住Ctrl 以每五度为单位旋转 白色的旋转线 是以目前你所看角度的旋转 按住shift 可以减速旋转 当需要精准的时候需要 S 跟随🖱变大缩小 T 呼出/隐藏菜单 Shift + A 添加物体 PBR（基于物理的渲染）工作流","link":"/2022/09/18/%E5%89%91%E9%AD%94%E7%AC%94%E8%AE%B0/"},{"title":"安装Vue脚手架和Webpack","text":"🔥 12345678910111213141516171819202122232425262728293031323334353637383940// 一、npm 版本查看及升级// 查看版本npm -v// 升级版本npm install -g npm//注：若npm install 报错 permission denied，使用sudo npm install -g npm🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝// 二、安装vue相关工具// 1. 安装vue// 最新稳定版npm install vue// 安装vue-cli脚手架构建工具npm install --global vue-cli//安装完成，输入vue -V，如果出现相应的版本号，则说明安装成功// 注：Mac 使用安装vue-cli脚手架的时候报错，// 解决方法：// 1.切换到/usr/local/lib/node_modules/目录// cd /usr/local/lib/node_modules/// 2.删除vue-cli文件夹// open /usr/local/lib/node_modules/// 3.重新安装vue-cli// npm install --global vue-cli// 2. 安装webpacknpm install --global webpacknpm install --global webpack-cli// --安装Webpack-dev-server只需要输入一行命令--npm install webpack-dev-server// 安装完成，输入webpack -v，如果出现相应的版本号，则说明安装成功🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝🥝// 三、新建项目// 1. 创建新项目// 创建一个基于 webpack 模板的新项目vue init webpack my-project// 这里需要进行一些配置，默认回车即可// 2. 运行项目cd my-projectnpm run dev// 成功应该自动弹出网页","link":"/2022/08/14/%E5%AE%89%E8%A3%85Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%92%8CWebpack/"},{"title":"害羞的人自救手册","text":"😳 注重自己的外表。长得好看不是必需品，但穿着得体是必要的（包括合适的发型，穿着时尚，微笑） 与积极的人相处，保持积极态度，平易近人。寻找周围积极向上的人身上的特点，值得注意的是，你并不应该假装有趣，或者假装自己的方式，这样会给人留一种只会找乐子的印象，应当做自己，享受自己做的事情 找一个兴趣。什么都行（汽车、环境、最新的电视剧电影） 不要太沉默寡言。也不要成为话瘤子，试图找到二者的平衡点 有信心，留意细节。因为它是提升自己最重要的方面之一，做自己喜欢的事情会让你充满信心 相信自己，告诉自己很棒。虽然这听起来很俗气，不要因为别人的评价而分心，重要的是你亲密朋友的意见，因为他们通常是诚实和直率的，不要听那些试图让你失望的人的话 开始锻炼。这不仅会让你看起来很好，而且也能促进健康饮食，并且对您的皮肤和肤色也有好处，迈向健康的生活方式 交朋友遵循的原则是简单。找到共同点，有共同感兴趣的东西，再去结合它，可以是有趣的，有帮助的，甚至是令人振奋的 远离消极的人。消极的人出现在你的生活中是一个巨大的风险，并且随时当着你的面大发雷霆 尝试做一些有意义又富有成效的事情。想象一下，如果你是一个只会打游戏和看抖音的网络巨婴，女孩子不觉得这样的人有吸引力，为自己找到有意义的工作，做自己的喜欢的事情，不去在乎什么，有你想要追求的目标并为之努力 学会为自己说话。并始终努力做得更好 想说什么就说什么。因为没关系，只要不冒犯或者荒谬 敞开心扉也会让她敞开心扉，这是建立良好对话的关键 永远记住第一印象 很重要 请诚实，不要无礼 如果邀请的话不必去贵，豪华的地方，任何你们俩可以度过愉快时光的地方都很好 在一些看起来不错的日子里，在朋友圈上发一些照片 如果你有名声，你应该自豪的去维护它 可以轻轻地取笑她，也可以有时取笑自己，或者尝试猜测她的答案来做到这一点，一个简单的规则就是不要做任何过度的事情 确保你在她的生活中扮演了一个可以完成的角色参与，不一定要一起出去玩，但让你们了解彼此的生活中发生的事情，重点是一起体验事物，分享这些体验 支持她说的话，让她觉得你可以依靠，在她需要的时候成为她会仰望的那个人 永远不要强迫女孩做任何事情，并在这样时做你自己，将注意力放回自己身上","link":"/2022/11/19/%E5%AE%B3%E7%BE%9E%E7%9A%84%E4%BA%BA%E8%87%AA%E6%95%91%E6%89%8B%E5%86%8C/"},{"title":"寻路算法","text":"🚀 A*(启发式搜索)F=G+HF:起点到终点的总代价G:从某一节点到开始节点的移动距离H:从某一节点到终点的估计移动距离 预估代价 欧拉距离 👉勾股定理 曼哈顿距离👉|x2-x1|+|y2-y1| 性能更强，不用开方","link":"/2022/12/04/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"},{"title":"我找不到童年写的情书","text":"🦄 像电影中的桥段 ? 结局亦是。","link":"/2021/07/07/%E6%88%91%E6%89%BE%E4%B8%8D%E5%88%B0%E7%AB%A5%E5%B9%B4%E5%86%99%E7%9A%84%E6%83%85%E4%B9%A6/"},{"title":"排序算法","text":"🚀 冒泡排序123456789101112131415161718192021222324252627arr = eval(input(&quot;请输入需要排序的值，以中文逗号分隔：&quot;))# print(type(arr[0]))# print(arr)# 可见eval函数起到了至关重要的作用l = len(arr)# 获取输入的个数# 冒泡排序def Bubble(arr: list, l: int): for i in range(l): for j in range(0, l-i-1): if arr[j] &gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j]# 需要对输入的数字转换成列表def ChangeArrTypeToList(arr): int_arr = [] for i in arr: int_arr.append(int(i)) return int_arr# 执行arr = ChangeArrTypeToList(arr)# print(type(ChangeArrTypeToList(arr)))#今日终于明确return的作用Bubble(arr, l)print(&quot;排序后的顺序：&quot;)for i in range(l): print(&quot;%d&quot; % arr[i])","link":"/2022/12/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"数据结构","text":"🚀 这里记录一些关于数据结构相关的东西 时间空间复杂度 BigO计算的是时间和空间增长的趋势 T(n)=O(f(n)) T(n)渐进复杂度 f(n)代码执行的次数 O()表示正比例关系 时间复杂度👇 越往左越好 空间复杂度👇 越往右越不好","link":"/2022/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"是可遇不可求🦄","text":"🦄 醒来还是会觉得一阵难过，又梦到你了，我想大概永远也不会再见着了，我知道你只想和我做好朋友，我又总是忍不住给你发消息，大概白月光就是说的就是这样的，不过想来现在连说说话都不可能，真的蛮后悔的，算起来时间都已经过去一年，也不知道有没有给我发过消息，如果你看到“对方已开启验证”，不知你是一种怎样的心情。 我俩本来永远不可能认识，是我人为地改变了命运，不过还是很高兴能遇见她 ，我也曾问过她“你是不是觉得我不是你的菜”，她回答“嗯”，我又问：“我长得不丑吧？”，她说其实蛮帅的只不过不是她喜欢的类型，或许是维护我的自尊，或许是我真的不是她喜欢的类型，总之我俩都和能感受到对方的心情，在我看来，那种关系是很舒适的，虽然每次我发消息给她，她都会回复，但总感觉缺少了点东西，这种感觉明显可以感受得到。我们之间没有什么藏着掖着的东西，有什么感受都会直接说，再后来再想找寻这种关系都没有遇着这样的，都不及她。或许再也遇不到了。 印象中的她，高高的瘦瘦的，身高大概一米七左右，长头发，头发弯弯的，皮肤白皙，喜欢穿粉色的外套 和 淡雅素青颜色的裙子，笑起来很是甜美，是真的像天使一般，写到这儿，我的心情更失落了，大概爱而不得的感受就是这样子的了，或者说友情以上，恋人未满的那种不甘。我与她是在专升本认识的，她学习也应该比我好，至少英文四级她是一次过的，据她说，她高考时英语考了130+，我问她怎么学好英语，她告诉我说其实全靠悟，搞懂每个句子是怎么构成的，一定要悟，然后背单词也是必不可少的。还有一些有趣的事情我已经记不清，但还是很荣幸能够认识这样一位人品、家教、容貌、才华兼具的女子。只能留在记忆里了，永远的白月光。 有时自己走在路上、在餐厅里看到容貌气质相似、旁边有男伴的女孩子也会感到唏嘘。也会感叹时间过得很快，害怕自己还没找到意中人就老了，每次见到自己头上多长一根白头发都会很难过。某个时刻觉得自己是在流浪，刻意找寻那种失落、孤单的感觉，情人节、中秋节都是一个人。不知道她也是否一样，不过我觉得她不是我这种人，我了解她，她是属于那种没有烦恼的人，一定在跟朋友一起吃好吃的或者男朋友一起漫步在路边的街灯下，可以想象得到那种花前月下的气氛。我也希望她能够过得幸福，因为我一直自诩为体面人。 尝试删除这段记忆，再后来见到中意的姑娘都会上去要联系方式，虽然大部分都会礼貌的给我微信，但其中不乏已经有对象的、女同性恋、海王中的海王、单身主义的、极端女权主义者的、转头就删好友的。。。我是真的没脾气😡，假如你看到这儿，不要觉得我如何如何，我想我为了完成一个夙愿，来趟这趟浑水，寻找希望，并不应该受到批判。但说实话，这也是我人为的介入，因为在命运里，我和这些人本来并没有认识的机会。在这些人里，少有把我当回事的，因此我只能默默地祈祷，并且变得坚硬。 待在出租屋里思考自己存在的意义，是应该隐忍，或许应该为自己定一个目标，或是成为某个行业的大佬，或是好好赚钱攒钱润去上学，我会一直好好过，即便一个人。 font{ background-image: linear-gradient(to right, orange, purple); -webkit-background-clip: text; color: transparent; } iframe{ text-align: center; }","link":"/2022/10/16/%E6%98%AF%E5%8F%AF%E9%81%87%E4%B8%8D%E5%8F%AF%E6%B1%82/"},{"title":"有时想记录一些东西","text":"💡 假如不记下来 ，我便会永远忘记 2022年9月1日😢我一个人在一家自助餐厅吃东西，看到前桌想起来以前的某位朋友，神态气质都很相似，我竟也分不清真假，这位朋友已经很久不联系了，说实话我真的很想念她。 2022年9月8日昨天下班回家，一对老年夫妇拦住了我，我以为他们要问路，我说我也是刚来这儿打工，不太清楚，大爷说他知道，他只是想让我给他俩买点吃的，他们说很饿，就花几块钱，说罢老奶奶就擦眼泪，我从未没见过这场面，更何况我也没钱，我这是第一次来济南打工，第一个月工资还没发，我神情有些惶恐，说我不是什么好人，于是我就走了，之后飞快的逃离，但我知道我没做错，更何况我低谷时也没人来帮我，我哭的时候绝对不会出声。后来也才知道是一种街头骗局、吃了东西会说肚子疼赔医药费之类的 2022年10月17日我采访了一个初中生，他告诉我他很想成为那种混的又好，学习又好的人，我问他怎么算混，他说吸烟，喝酒，泡网吧，原来，这与我理解的不一样，不过现在的小孩倒是挺成熟的。 2022年11月18日如何快速学会任何技能：画画、吉他、编程…渗流自用:1.理论知识学的刚刚好就行不用从第一页开始看2.明确目标，代入学会的情景，把目标具体化比如为了能在女朋友生日上谈这首曲子3.找3个以上学习资源，从不同观点学习，如果走了弯路还有别的资源可以救回来4.制定学习计划，把要学的东西拆分学再组合到一起练习5.多实践，模仿做几个练习，最后再自己做一个教程上没有的东西6.复盘失败7.教给别人","link":"/2022/11/18/%E6%9C%89%E6%97%B6%E6%83%B3%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/"},{"title":"看过的电影","text":"🎦 阿飞正传华尔街之狼肖申克的救赎小丑🤡阿甘正传花样年华杀生同桌的你胭脂扣","link":"/2022/07/02/%E7%9C%8B%E8%BF%87%E7%9A%84%E7%94%B5%E5%BD%B1/"},{"title":"桌面快捷方式变白解决办法","text":"🚀 新建一个txt文件将以下内容粘贴进去，并改后缀为.bat，运行 12345@echo offtaskkill /f /im explorer.exeCD /d %userprofile%\\AppData\\LocalDEL IconCache.db /astart explorer.exe","link":"/2022/07/12/%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%8F%98%E7%99%BD%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"移除右键菜单&quot;在VisualStudio中打开&quot;","text":"🚀 新建一个txt文件，将以下内容粘贴进去，保存改后缀为.reg格式，运行 123Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\AnyCode][-HKEY_CLASSES_ROOT\\Directory\\shell\\AnyCode]","link":"/2022/07/12/%E7%A7%BB%E9%99%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%9C%A8VisualStudio%E4%B8%AD%E6%89%93%E5%BC%80/"},{"title":"算法面试题","text":"🥧 0-235 有多少个 1 ？12345678num = 0for items in range(236): for item in str(items): if item=='1': num+=1print(num) 解析： 循环从 0-235 ，因此需要填写 236 的范围 将 items 转成字符类型可以算是个数组 第二个 for 循环的 item 将检测 items 是否含有 1 如果有那么 num 将 +1 当 items 为 111 的时候相当于加了三次 改进一下👇 如果每个数字只允许出现一次呢？ 123456789101112131415161718num = 0b = Truefor items in range(0,236): for item in str(items): if item=='1' and b: num+=1 b=not b print(items,item) b=not bprint(num) 解析： 那么只需要加个布尔检测即可 字符串搜索 暴力算法 hash算法 BM算法 ⭐ 坏字符规则 好字符规则 KMP算法 ⭐","link":"/2022/12/26/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"绘画基础|色彩|形状","text":"👾 和谐の颜色搭配调制和谐的色彩有三种常用的办法 使用对比色👉不过尽量淡些，对眼睛友好 单色👉只需修改饱和度低的亮度，呈斜线选色 选一个颜色和它色轮相邻的两个颜色👆（是2的推广） 遵循原则 线条干净 √ 对比色 正负空间 主题为+，尽量不要画难以区分正负难辨 光线 意味着哪里是暗的（先找暗的） 饱和度（颜色的浓度） 技巧 先用普通笔刷画出轮廓 再缩小描边 填色 HSL取色模式 更符合直觉但是相对也会改变一些hue值一般是变亮，其hue值往反方向调整，反之亦然(周围环境反射也是影响因素) 形状地球上任何事物都可以抽象成最简单的几何体 胳膊可以想象成圆柱体苹果可以想象成球甜筒可以想象成圆锥","link":"/2022/12/03/%E7%BB%98%E7%94%BB%E5%9F%BA%E7%A1%80/"},{"title":"编辑器美化指南","text":"🔧 包括字体、图标、主题涉及编辑器有VS、VS Code、VS Code Bate版毕竟也是微软粉 ，嘻嘻🤭 字体传统一点的程序员呢 大多是喜欢用 MONACO 这个字体库，因为在MacOS上这是默认字体，因此出于习惯保留下来，Windows平台没有，但是可以下载安装，效果还不错，但是个人感觉不是很喜欢这个字体，于是四处寻找找到了一款名为 FiraCode 的字体，不仅易分辨字符，还很有趣，更多请自行探索(●’◡’●) 安装完毕后（windows上一般使用.ttf格式，选中所有全部安装），在VS上比较好使用 在工具👉设置👉字体与颜色选中即可，但是VS Code上需要更改json文件，具体步骤如下：首选项👉设置👉搜索“字体”，然后在出现的 font family 使用单引号名字加入这个字体，具体如下图 之后在font ligatures里改为 12&quot;editor.fontFamily&quot;: &quot;Fira Code&quot;,&quot;editor.fontLigatures&quot;: true, 之后便可以启用了 FiraCode字体下载地址：https://github.com/tonsky/FiraCode 图标这个没什么好说的，个人一直统一使用 vscode-icons，但是不少人也比较喜欢Material Icon Theme，这两款图标排行都是在第一第二，但我感觉还是前者更具有现代气息 主题平时使用VS Code正式版写markdown比较多，VScode测试版写代码，所以主题一定要使用不一样的，所以One Dark Pro给了平常写代码的，因为显得更pro一些 🤭，写笔记的是 Dracula（吸血鬼主题，但是蓝粉相间颇有一丝赛博朋克风格），VS用的也是德古拉吸血鬼，确实很帅啊~ 🧛‍","link":"/2022/08/29/%E7%BC%96%E8%BE%91%E5%99%A8%E7%BE%8E%E5%8C%96%E6%8C%87%E5%8D%97/"},{"title":"装备一览表","text":"🚀 苦于经常更换电脑环境，因此记录了一些必备的软件，方便以后下载开发基础clash git(清华开源镜像) nodejs/npm浏览器edge盗版 tete009火狐 360极速浏览器编辑器vscode vs Rider下载工具idm免注册版 文件蜈蚣存储阿里网盘 百度网盘笔记zohoNote录屏OBS(清华开源镜像) Bandicam免注册版文档WPS绿色版U盘启动制作Rufus","link":"/2022/10/17/%E8%A3%85%E5%A4%87%E4%B8%80%E8%A7%88%E8%A1%A8/"},{"title":"道具列表","text":"💊 酒精湿巾抽纸眼药水 新冠礼包👇","link":"/2022/12/15/%E9%81%93%E5%85%B7%E5%88%97%E8%A1%A8/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"🔥Unity🔥","slug":"🔥Unity🔥","link":"/tags/%F0%9F%94%A5Unity%F0%9F%94%A5/"},{"name":"💧Three💧","slug":"💧Three💧","link":"/tags/%F0%9F%92%A7Three%F0%9F%92%A7/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"像素画","slug":"像素画","link":"/tags/%E5%83%8F%E7%B4%A0%E7%94%BB/"}],"categories":[{"name":"程序生涯","slug":"程序生涯","link":"/categories/%E7%A8%8B%E5%BA%8F%E7%94%9F%E6%B6%AF/"},{"name":"艺术设计","slug":"艺术设计","link":"/categories/%E8%89%BA%E6%9C%AF%E8%AE%BE%E8%AE%A1/"},{"name":"Web开发","slug":"Web开发","link":"/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"游戏开发","slug":"游戏开发","link":"/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"备忘录","slug":"备忘录","link":"/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"生活记录","slug":"生活记录","link":"/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/"}],"pages":[]}